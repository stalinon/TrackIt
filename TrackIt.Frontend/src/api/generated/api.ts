/* tslint:disable */
/* eslint-disable */
/**
 * TrackIt API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Модель общего баланса
 * @export
 * @interface BalanceDto
 */
export interface BalanceDto {
    /**
     * Сумма всех доходов
     * @type {number}
     * @memberof BalanceDto
     */
    'total_income'?: number;
    /**
     * Сумма всех расходов
     * @type {number}
     * @memberof BalanceDto
     */
    'total_expense'?: number;
    /**
     * Баланс
     * @type {number}
     * @memberof BalanceDto
     */
    'balance'?: number;
}
/**
 * Модель лимита бюджета
 * @export
 * @interface BudgetDto
 */
export interface BudgetDto {
    /**
     * Уникальный идентификатор
     * @type {string}
     * @memberof BudgetDto
     */
    'id'?: string;
    /**
     * Величина лимита
     * @type {number}
     * @memberof BudgetDto
     */
    'amount'?: number;
    /**
     * Идентификатор категории
     * @type {string}
     * @memberof BudgetDto
     */
    'category_id'?: string | null;
}
/**
 * Пагинированный список
 * @export
 * @interface BudgetDtoPagedList
 */
export interface BudgetDtoPagedList {
    /**
     * Элементы
     * @type {Array<BudgetDto>}
     * @memberof BudgetDtoPagedList
     */
    'items'?: Array<BudgetDto> | null;
    /**
     * Всего элементов
     * @type {number}
     * @memberof BudgetDtoPagedList
     */
    'total'?: number;
}
/**
 * Модель категории
 * @export
 * @interface CategoryDto
 */
export interface CategoryDto {
    /**
     * Уникальный идентификатор категории
     * @type {string}
     * @memberof CategoryDto
     */
    'id'?: string;
    /**
     * Название категории
     * @type {string}
     * @memberof CategoryDto
     */
    'name'?: string | null;
    /**
     * 
     * @type {CategoryType}
     * @memberof CategoryDto
     */
    'type'?: CategoryType;
    /**
     * Идентификатор пользователя
     * @type {string}
     * @memberof CategoryDto
     */
    'user_id'?: string;
}


/**
 * Пагинированный список
 * @export
 * @interface CategoryDtoPagedList
 */
export interface CategoryDtoPagedList {
    /**
     * Элементы
     * @type {Array<CategoryDto>}
     * @memberof CategoryDtoPagedList
     */
    'items'?: Array<CategoryDto> | null;
    /**
     * Всего элементов
     * @type {number}
     * @memberof CategoryDtoPagedList
     */
    'total'?: number;
}
/**
 * Модель траты по категории
 * @export
 * @interface CategorySpendingDto
 */
export interface CategorySpendingDto {
    /**
     * Название категории
     * @type {string}
     * @memberof CategorySpendingDto
     */
    'category'?: string | null;
    /**
     * Всего потрачено
     * @type {number}
     * @memberof CategorySpendingDto
     */
    'total_spent'?: number;
}
/**
 * Тип категории
 * @export
 * @enum {number}
 */

export const CategoryType = {
    NUMBER_1: 1,
    NUMBER_MINUS_1: -1
} as const;

export type CategoryType = typeof CategoryType[keyof typeof CategoryType];


/**
 * Запрос на создание запланированного платежа
 * @export
 * @interface CreateBudgetCommand
 */
export interface CreateBudgetCommand {
    /**
     * Идентификатор категории
     * @type {string}
     * @memberof CreateBudgetCommand
     */
    'category_id'?: string;
    /**
     * Величина лимита
     * @type {number}
     * @memberof CreateBudgetCommand
     */
    'amount'?: number;
}
/**
 * Запрос на создание категории
 * @export
 * @interface CreateCategoryCommand
 */
export interface CreateCategoryCommand {
    /**
     * Название категории
     * @type {string}
     * @memberof CreateCategoryCommand
     */
    'name'?: string | null;
    /**
     * 
     * @type {CategoryType}
     * @memberof CreateCategoryCommand
     */
    'type'?: CategoryType;
}


/**
 * Запрос на создание запланированного платежа
 * @export
 * @interface CreatePlannedPaymentCommand
 */
export interface CreatePlannedPaymentCommand {
    /**
     * Идентификатор категории
     * @type {string}
     * @memberof CreatePlannedPaymentCommand
     */
    'category_id'?: string;
    /**
     * Объем оплаты
     * @type {number}
     * @memberof CreatePlannedPaymentCommand
     */
    'amount'?: number;
    /**
     * Дата
     * @type {string}
     * @memberof CreatePlannedPaymentCommand
     */
    'due_date'?: string;
    /**
     * Описание
     * @type {string}
     * @memberof CreatePlannedPaymentCommand
     */
    'description'?: string | null;
}
/**
 * Команда для создания новой транзакции.
 * @export
 * @interface CreateTransactionCommand
 */
export interface CreateTransactionCommand {
    /**
     * Идентификатор категории.
     * @type {string}
     * @memberof CreateTransactionCommand
     */
    'category_id'?: string;
    /**
     * Сумма транзакции.
     * @type {number}
     * @memberof CreateTransactionCommand
     */
    'amount'?: number;
    /**
     * Описание транзакции.
     * @type {string}
     * @memberof CreateTransactionCommand
     */
    'description'?: string | null;
    /**
     * Дата транзакции.
     * @type {string}
     * @memberof CreateTransactionCommand
     */
    'date'?: string;
}
/**
 * Модель дневных трат
 * @export
 * @interface DailySpendingDto
 */
export interface DailySpendingDto {
    /**
     * Номер дня
     * @type {number}
     * @memberof DailySpendingDto
     */
    'day'?: number;
    /**
     * Всего потрачено
     * @type {number}
     * @memberof DailySpendingDto
     */
    'total_spent'?: number;
}
/**
 * Детализированная модель лимита бюджета
 * @export
 * @interface DetailedBudgetDto
 */
export interface DetailedBudgetDto {
    /**
     * Уникальный идентификатор
     * @type {string}
     * @memberof DetailedBudgetDto
     */
    'id'?: string;
    /**
     * Величина лимита
     * @type {number}
     * @memberof DetailedBudgetDto
     */
    'amount'?: number;
    /**
     * Идентификатор категории
     * @type {string}
     * @memberof DetailedBudgetDto
     */
    'category_id'?: string | null;
    /**
     * Дата создания
     * @type {string}
     * @memberof DetailedBudgetDto
     */
    'created_at'?: string;
    /**
     * Дата обновления
     * @type {string}
     * @memberof DetailedBudgetDto
     */
    'updated_at'?: string;
}
/**
 * Детализированная модель категории
 * @export
 * @interface DetailedCategoryDto
 */
export interface DetailedCategoryDto {
    /**
     * Уникальный идентификатор категории
     * @type {string}
     * @memberof DetailedCategoryDto
     */
    'id'?: string;
    /**
     * Название категории
     * @type {string}
     * @memberof DetailedCategoryDto
     */
    'name'?: string | null;
    /**
     * 
     * @type {CategoryType}
     * @memberof DetailedCategoryDto
     */
    'type'?: CategoryType;
    /**
     * Идентификатор пользователя
     * @type {string}
     * @memberof DetailedCategoryDto
     */
    'user_id'?: string;
    /**
     * Дата создания
     * @type {string}
     * @memberof DetailedCategoryDto
     */
    'created_at'?: string;
    /**
     * Дата обновления
     * @type {string}
     * @memberof DetailedCategoryDto
     */
    'updated_at'?: string;
}


/**
 * Детализированная модель запланированной платы
 * @export
 * @interface DetailedPlannedPaymentDto
 */
export interface DetailedPlannedPaymentDto {
    /**
     * Уникальный идентификатор
     * @type {string}
     * @memberof DetailedPlannedPaymentDto
     */
    'id'?: string;
    /**
     * Объем оплаты
     * @type {number}
     * @memberof DetailedPlannedPaymentDto
     */
    'amount'?: number;
    /**
     * Дата
     * @type {string}
     * @memberof DetailedPlannedPaymentDto
     */
    'due_date'?: string;
    /**
     * Идентификатор категории
     * @type {string}
     * @memberof DetailedPlannedPaymentDto
     */
    'category_id'?: string | null;
    /**
     * Описание
     * @type {string}
     * @memberof DetailedPlannedPaymentDto
     */
    'description'?: string | null;
    /**
     * Дата создания
     * @type {string}
     * @memberof DetailedPlannedPaymentDto
     */
    'created_at'?: string;
    /**
     * Дата обновления
     * @type {string}
     * @memberof DetailedPlannedPaymentDto
     */
    'updated_at'?: string;
}
/**
 * Детализированная модель транзакции
 * @export
 * @interface DetailedTransactionDto
 */
export interface DetailedTransactionDto {
    /**
     * Уникальный идентификатор транзакции.
     * @type {string}
     * @memberof DetailedTransactionDto
     */
    'id'?: string;
    /**
     * Уникальный идентификатор пользователя.
     * @type {string}
     * @memberof DetailedTransactionDto
     */
    'user_id'?: string;
    /**
     * Сумма транзакции.
     * @type {number}
     * @memberof DetailedTransactionDto
     */
    'amount'?: number;
    /**
     * Дата транзакции.
     * @type {string}
     * @memberof DetailedTransactionDto
     */
    'date'?: string;
    /**
     * Дата создания
     * @type {string}
     * @memberof DetailedTransactionDto
     */
    'created_at'?: string;
    /**
     * Дата обновления
     * @type {string}
     * @memberof DetailedTransactionDto
     */
    'updated_at'?: string;
    /**
     * Описание
     * @type {string}
     * @memberof DetailedTransactionDto
     */
    'description'?: string | null;
    /**
     * Идентификатор категории
     * @type {string}
     * @memberof DetailedTransactionDto
     */
    'category_id'?: string | null;
}
/**
 * Модель средних затрат
 * @export
 * @interface MonthlyAverageDto
 */
export interface MonthlyAverageDto {
    /**
     * Средние затраты
     * @type {number}
     * @memberof MonthlyAverageDto
     */
    'average_month_spent'?: number;
}
/**
 * Модель запланированной платы
 * @export
 * @interface PlannedPaymentDto
 */
export interface PlannedPaymentDto {
    /**
     * Уникальный идентификатор
     * @type {string}
     * @memberof PlannedPaymentDto
     */
    'id'?: string;
    /**
     * Объем оплаты
     * @type {number}
     * @memberof PlannedPaymentDto
     */
    'amount'?: number;
    /**
     * Дата
     * @type {string}
     * @memberof PlannedPaymentDto
     */
    'due_date'?: string;
    /**
     * Идентификатор категории
     * @type {string}
     * @memberof PlannedPaymentDto
     */
    'category_id'?: string | null;
}
/**
 * Пагинированный список
 * @export
 * @interface PlannedPaymentDtoPagedList
 */
export interface PlannedPaymentDtoPagedList {
    /**
     * Элементы
     * @type {Array<PlannedPaymentDto>}
     * @memberof PlannedPaymentDtoPagedList
     */
    'items'?: Array<PlannedPaymentDto> | null;
    /**
     * Всего элементов
     * @type {number}
     * @memberof PlannedPaymentDtoPagedList
     */
    'total'?: number;
}
/**
 * Модель самых затратных категорий
 * @export
 * @interface TopCategoryDto
 */
export interface TopCategoryDto {
    /**
     * Название категории
     * @type {string}
     * @memberof TopCategoryDto
     */
    'category'?: string | null;
    /**
     * Всего потрачено
     * @type {number}
     * @memberof TopCategoryDto
     */
    'total_spent'?: number;
}
/**
 * Модель транзакции
 * @export
 * @interface TransactionDto
 */
export interface TransactionDto {
    /**
     * Уникальный идентификатор транзакции.
     * @type {string}
     * @memberof TransactionDto
     */
    'id'?: string;
    /**
     * Уникальный идентификатор пользователя.
     * @type {string}
     * @memberof TransactionDto
     */
    'user_id'?: string;
    /**
     * Сумма транзакции.
     * @type {number}
     * @memberof TransactionDto
     */
    'amount'?: number;
    /**
     * Дата транзакции.
     * @type {string}
     * @memberof TransactionDto
     */
    'date'?: string;
}
/**
 * Пагинированный список
 * @export
 * @interface TransactionDtoPagedList
 */
export interface TransactionDtoPagedList {
    /**
     * Элементы
     * @type {Array<TransactionDto>}
     * @memberof TransactionDtoPagedList
     */
    'items'?: Array<TransactionDto> | null;
    /**
     * Всего элементов
     * @type {number}
     * @memberof TransactionDtoPagedList
     */
    'total'?: number;
}
/**
 * Запрос на обновление запланированного платежа
 * @export
 * @interface UpdateBudgetCommand
 */
export interface UpdateBudgetCommand {
    /**
     * Идентификатор запланированного платежа
     * @type {string}
     * @memberof UpdateBudgetCommand
     */
    'id'?: string;
    /**
     * Величина лимита
     * @type {number}
     * @memberof UpdateBudgetCommand
     */
    'amount'?: number;
    /**
     * Идентификатор категории
     * @type {string}
     * @memberof UpdateBudgetCommand
     */
    'category_id'?: string | null;
}
/**
 * Запрос на обновление категории
 * @export
 * @interface UpdateCategoryCommand
 */
export interface UpdateCategoryCommand {
    /**
     * Уникальный идентификатор категории
     * @type {string}
     * @memberof UpdateCategoryCommand
     */
    'id'?: string;
    /**
     * Название категории
     * @type {string}
     * @memberof UpdateCategoryCommand
     */
    'name'?: string | null;
    /**
     * 
     * @type {CategoryType}
     * @memberof UpdateCategoryCommand
     */
    'type'?: CategoryType;
}


/**
 * Запрос на обновление запланированного платежа
 * @export
 * @interface UpdatePlannedPaymentCommand
 */
export interface UpdatePlannedPaymentCommand {
    /**
     * Идентификатор запланированного платежа
     * @type {string}
     * @memberof UpdatePlannedPaymentCommand
     */
    'id'?: string;
    /**
     * Объем оплаты
     * @type {number}
     * @memberof UpdatePlannedPaymentCommand
     */
    'amount'?: number;
    /**
     * Дата
     * @type {string}
     * @memberof UpdatePlannedPaymentCommand
     */
    'due_date'?: string;
    /**
     * Описание
     * @type {string}
     * @memberof UpdatePlannedPaymentCommand
     */
    'description'?: string | null;
    /**
     * Идентификатор категории
     * @type {string}
     * @memberof UpdatePlannedPaymentCommand
     */
    'category_id'?: string | null;
}
/**
 * Команда для обновления транзакции.
 * @export
 * @interface UpdateTransactionCommand
 */
export interface UpdateTransactionCommand {
    /**
     * Уникальный идентификатор транзакции.
     * @type {string}
     * @memberof UpdateTransactionCommand
     */
    'id'?: string;
    /**
     * Уникальный идентификатор категории.
     * @type {string}
     * @memberof UpdateTransactionCommand
     */
    'category_id'?: string;
    /**
     * Сумма транзакции.
     * @type {number}
     * @memberof UpdateTransactionCommand
     */
    'amount'?: number;
    /**
     * Описание транзакции.
     * @type {string}
     * @memberof UpdateTransactionCommand
     */
    'description'?: string | null;
    /**
     * Дата транзакции.
     * @type {string}
     * @memberof UpdateTransactionCommand
     */
    'date'?: string;
}
/**
 * Модель пользователя
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     * Идентификатор
     * @type {string}
     * @memberof UserDto
     */
    'id'?: string;
    /**
     * Электронная почта
     * @type {string}
     * @memberof UserDto
     */
    'email'?: string | null;
    /**
     * Дата создания
     * @type {string}
     * @memberof UserDto
     */
    'createdAt'?: string;
}

/**
 * AnalyticsApi - axios parameter creator
 * @export
 */
export const AnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Получение общего баланса пользователя
         * @param {object} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAnalyticsBalanceGet: async (query?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/analytics/balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                for (const [key, value] of Object.entries(query)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Получение расходов по категориям
         * @param {object} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAnalyticsCategorySpendingGet: async (query?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/analytics/category-spending`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                for (const [key, value] of Object.entries(query)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Получение среднего уровня месячных расходов
         * @param {object} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAnalyticsMonthlyAverageGet: async (query?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/analytics/monthly-average`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                for (const [key, value] of Object.entries(query)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Получение динамики расходов за месяц
         * @param {object} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAnalyticsMonthlyTrendGet: async (query?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/analytics/monthly-trend`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                for (const [key, value] of Object.entries(query)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Получение топ-3 самых затратных категорий
         * @param {object} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAnalyticsTopCategoriesGet: async (query?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/analytics/top-categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                for (const [key, value] of Object.entries(query)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalyticsApi - functional programming interface
 * @export
 */
export const AnalyticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalyticsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Получение общего баланса пользователя
         * @param {object} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAnalyticsBalanceGet(query?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAnalyticsBalanceGet(query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.apiAnalyticsBalanceGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Получение расходов по категориям
         * @param {object} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAnalyticsCategorySpendingGet(query?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CategorySpendingDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAnalyticsCategorySpendingGet(query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.apiAnalyticsCategorySpendingGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Получение среднего уровня месячных расходов
         * @param {object} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAnalyticsMonthlyAverageGet(query?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MonthlyAverageDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAnalyticsMonthlyAverageGet(query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.apiAnalyticsMonthlyAverageGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Получение динамики расходов за месяц
         * @param {object} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAnalyticsMonthlyTrendGet(query?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DailySpendingDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAnalyticsMonthlyTrendGet(query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.apiAnalyticsMonthlyTrendGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Получение топ-3 самых затратных категорий
         * @param {object} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAnalyticsTopCategoriesGet(query?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TopCategoryDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAnalyticsTopCategoriesGet(query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.apiAnalyticsTopCategoriesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnalyticsApi - factory interface
 * @export
 */
export const AnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalyticsApiFp(configuration)
    return {
        /**
         * 
         * @summary Получение общего баланса пользователя
         * @param {object} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAnalyticsBalanceGet(query?: object, options?: RawAxiosRequestConfig): AxiosPromise<BalanceDto> {
            return localVarFp.apiAnalyticsBalanceGet(query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Получение расходов по категориям
         * @param {object} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAnalyticsCategorySpendingGet(query?: object, options?: RawAxiosRequestConfig): AxiosPromise<Array<CategorySpendingDto>> {
            return localVarFp.apiAnalyticsCategorySpendingGet(query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Получение среднего уровня месячных расходов
         * @param {object} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAnalyticsMonthlyAverageGet(query?: object, options?: RawAxiosRequestConfig): AxiosPromise<MonthlyAverageDto> {
            return localVarFp.apiAnalyticsMonthlyAverageGet(query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Получение динамики расходов за месяц
         * @param {object} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAnalyticsMonthlyTrendGet(query?: object, options?: RawAxiosRequestConfig): AxiosPromise<Array<DailySpendingDto>> {
            return localVarFp.apiAnalyticsMonthlyTrendGet(query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Получение топ-3 самых затратных категорий
         * @param {object} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAnalyticsTopCategoriesGet(query?: object, options?: RawAxiosRequestConfig): AxiosPromise<Array<TopCategoryDto>> {
            return localVarFp.apiAnalyticsTopCategoriesGet(query, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
export class AnalyticsApi extends BaseAPI {
    /**
     * 
     * @summary Получение общего баланса пользователя
     * @param {object} [query] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public apiAnalyticsBalanceGet(query?: object, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).apiAnalyticsBalanceGet(query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Получение расходов по категориям
     * @param {object} [query] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public apiAnalyticsCategorySpendingGet(query?: object, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).apiAnalyticsCategorySpendingGet(query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Получение среднего уровня месячных расходов
     * @param {object} [query] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public apiAnalyticsMonthlyAverageGet(query?: object, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).apiAnalyticsMonthlyAverageGet(query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Получение динамики расходов за месяц
     * @param {object} [query] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public apiAnalyticsMonthlyTrendGet(query?: object, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).apiAnalyticsMonthlyTrendGet(query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Получение топ-3 самых затратных категорий
     * @param {object} [query] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public apiAnalyticsTopCategoriesGet(query?: object, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).apiAnalyticsTopCategoriesGet(query, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BudgetApi - axios parameter creator
 * @export
 */
export const BudgetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Получение всех лимитов
         * @param {string} [categoryId] Идентификатор категории
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Предел
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBudgetsGet: async (categoryId?: string, page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/budgets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (categoryId !== undefined) {
                localVarQueryParameter['category_id'] = categoryId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Удаление лимита
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBudgetsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiBudgetsIdDelete', 'id', id)
            const localVarPath = `/api/budgets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Получение лимита по ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBudgetsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiBudgetsIdGet', 'id', id)
            const localVarPath = `/api/budgets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Обновление лимита
         * @param {string} id 
         * @param {UpdateBudgetCommand} [updateBudgetCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBudgetsIdPut: async (id: string, updateBudgetCommand?: UpdateBudgetCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiBudgetsIdPut', 'id', id)
            const localVarPath = `/api/budgets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateBudgetCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Создание лимита
         * @param {CreateBudgetCommand} [createBudgetCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBudgetsPost: async (createBudgetCommand?: CreateBudgetCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/budgets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBudgetCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BudgetApi - functional programming interface
 * @export
 */
export const BudgetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BudgetApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Получение всех лимитов
         * @param {string} [categoryId] Идентификатор категории
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Предел
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBudgetsGet(categoryId?: string, page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetDtoPagedList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBudgetsGet(categoryId, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BudgetApi.apiBudgetsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Удаление лимита
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBudgetsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBudgetsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BudgetApi.apiBudgetsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Получение лимита по ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBudgetsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedBudgetDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBudgetsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BudgetApi.apiBudgetsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Обновление лимита
         * @param {string} id 
         * @param {UpdateBudgetCommand} [updateBudgetCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBudgetsIdPut(id: string, updateBudgetCommand?: UpdateBudgetCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBudgetsIdPut(id, updateBudgetCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BudgetApi.apiBudgetsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Создание лимита
         * @param {CreateBudgetCommand} [createBudgetCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBudgetsPost(createBudgetCommand?: CreateBudgetCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBudgetsPost(createBudgetCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BudgetApi.apiBudgetsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BudgetApi - factory interface
 * @export
 */
export const BudgetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BudgetApiFp(configuration)
    return {
        /**
         * 
         * @summary Получение всех лимитов
         * @param {string} [categoryId] Идентификатор категории
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Предел
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBudgetsGet(categoryId?: string, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<BudgetDtoPagedList> {
            return localVarFp.apiBudgetsGet(categoryId, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Удаление лимита
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBudgetsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiBudgetsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Получение лимита по ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBudgetsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DetailedBudgetDto> {
            return localVarFp.apiBudgetsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Обновление лимита
         * @param {string} id 
         * @param {UpdateBudgetCommand} [updateBudgetCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBudgetsIdPut(id: string, updateBudgetCommand?: UpdateBudgetCommand, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiBudgetsIdPut(id, updateBudgetCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Создание лимита
         * @param {CreateBudgetCommand} [createBudgetCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBudgetsPost(createBudgetCommand?: CreateBudgetCommand, options?: RawAxiosRequestConfig): AxiosPromise<BudgetDto> {
            return localVarFp.apiBudgetsPost(createBudgetCommand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BudgetApi - object-oriented interface
 * @export
 * @class BudgetApi
 * @extends {BaseAPI}
 */
export class BudgetApi extends BaseAPI {
    /**
     * 
     * @summary Получение всех лимитов
     * @param {string} [categoryId] Идентификатор категории
     * @param {number} [page] Номер страницы
     * @param {number} [limit] Предел
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetApi
     */
    public apiBudgetsGet(categoryId?: string, page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return BudgetApiFp(this.configuration).apiBudgetsGet(categoryId, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Удаление лимита
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetApi
     */
    public apiBudgetsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return BudgetApiFp(this.configuration).apiBudgetsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Получение лимита по ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetApi
     */
    public apiBudgetsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return BudgetApiFp(this.configuration).apiBudgetsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Обновление лимита
     * @param {string} id 
     * @param {UpdateBudgetCommand} [updateBudgetCommand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetApi
     */
    public apiBudgetsIdPut(id: string, updateBudgetCommand?: UpdateBudgetCommand, options?: RawAxiosRequestConfig) {
        return BudgetApiFp(this.configuration).apiBudgetsIdPut(id, updateBudgetCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Создание лимита
     * @param {CreateBudgetCommand} [createBudgetCommand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetApi
     */
    public apiBudgetsPost(createBudgetCommand?: CreateBudgetCommand, options?: RawAxiosRequestConfig) {
        return BudgetApiFp(this.configuration).apiBudgetsPost(createBudgetCommand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CategoriesApi - axios parameter creator
 * @export
 */
export const CategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Получение всех категорий
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Предел
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCategoriesGet: async (page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Удаление категории
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCategoriesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCategoriesIdDelete', 'id', id)
            const localVarPath = `/api/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Получение категории по ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCategoriesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCategoriesIdGet', 'id', id)
            const localVarPath = `/api/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Обновление категории
         * @param {string} id 
         * @param {UpdateCategoryCommand} [updateCategoryCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCategoriesIdPut: async (id: string, updateCategoryCommand?: UpdateCategoryCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCategoriesIdPut', 'id', id)
            const localVarPath = `/api/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCategoryCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Создание категории
         * @param {CreateCategoryCommand} [createCategoryCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCategoriesPost: async (createCategoryCommand?: CreateCategoryCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCategoryCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoriesApi - functional programming interface
 * @export
 */
export const CategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Получение всех категорий
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Предел
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCategoriesGet(page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryDtoPagedList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCategoriesGet(page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.apiCategoriesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Удаление категории
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCategoriesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCategoriesIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.apiCategoriesIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Получение категории по ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCategoriesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedCategoryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCategoriesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.apiCategoriesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Обновление категории
         * @param {string} id 
         * @param {UpdateCategoryCommand} [updateCategoryCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCategoriesIdPut(id: string, updateCategoryCommand?: UpdateCategoryCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCategoriesIdPut(id, updateCategoryCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.apiCategoriesIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Создание категории
         * @param {CreateCategoryCommand} [createCategoryCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCategoriesPost(createCategoryCommand?: CreateCategoryCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCategoriesPost(createCategoryCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.apiCategoriesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CategoriesApi - factory interface
 * @export
 */
export const CategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Получение всех категорий
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Предел
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCategoriesGet(page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<CategoryDtoPagedList> {
            return localVarFp.apiCategoriesGet(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Удаление категории
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCategoriesIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiCategoriesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Получение категории по ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCategoriesIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DetailedCategoryDto> {
            return localVarFp.apiCategoriesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Обновление категории
         * @param {string} id 
         * @param {UpdateCategoryCommand} [updateCategoryCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCategoriesIdPut(id: string, updateCategoryCommand?: UpdateCategoryCommand, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiCategoriesIdPut(id, updateCategoryCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Создание категории
         * @param {CreateCategoryCommand} [createCategoryCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCategoriesPost(createCategoryCommand?: CreateCategoryCommand, options?: RawAxiosRequestConfig): AxiosPromise<CategoryDto> {
            return localVarFp.apiCategoriesPost(createCategoryCommand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
export class CategoriesApi extends BaseAPI {
    /**
     * 
     * @summary Получение всех категорий
     * @param {number} [page] Номер страницы
     * @param {number} [limit] Предел
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public apiCategoriesGet(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).apiCategoriesGet(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Удаление категории
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public apiCategoriesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).apiCategoriesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Получение категории по ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public apiCategoriesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).apiCategoriesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Обновление категории
     * @param {string} id 
     * @param {UpdateCategoryCommand} [updateCategoryCommand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public apiCategoriesIdPut(id: string, updateCategoryCommand?: UpdateCategoryCommand, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).apiCategoriesIdPut(id, updateCategoryCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Создание категории
     * @param {CreateCategoryCommand} [createCategoryCommand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public apiCategoriesPost(createCategoryCommand?: CreateCategoryCommand, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).apiCategoriesPost(createCategoryCommand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PlannedPaymentApi - axios parameter creator
 * @export
 */
export const PlannedPaymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Получение всех платежей
         * @param {string} [categoryId] Идентификатор категории
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Предел
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsGet: async (categoryId?: string, page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (categoryId !== undefined) {
                localVarQueryParameter['category_id'] = categoryId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Удаление платежа
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPaymentsIdDelete', 'id', id)
            const localVarPath = `/api/payments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Получение платежа по ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPaymentsIdGet', 'id', id)
            const localVarPath = `/api/payments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Обновление платежа
         * @param {string} id 
         * @param {UpdatePlannedPaymentCommand} [updatePlannedPaymentCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsIdPut: async (id: string, updatePlannedPaymentCommand?: UpdatePlannedPaymentCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPaymentsIdPut', 'id', id)
            const localVarPath = `/api/payments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePlannedPaymentCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Создание платежа
         * @param {CreatePlannedPaymentCommand} [createPlannedPaymentCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsPost: async (createPlannedPaymentCommand?: CreatePlannedPaymentCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPlannedPaymentCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlannedPaymentApi - functional programming interface
 * @export
 */
export const PlannedPaymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlannedPaymentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Получение всех платежей
         * @param {string} [categoryId] Идентификатор категории
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Предел
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPaymentsGet(categoryId?: string, page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlannedPaymentDtoPagedList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPaymentsGet(categoryId, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlannedPaymentApi.apiPaymentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Удаление платежа
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPaymentsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPaymentsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlannedPaymentApi.apiPaymentsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Получение платежа по ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPaymentsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedPlannedPaymentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPaymentsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlannedPaymentApi.apiPaymentsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Обновление платежа
         * @param {string} id 
         * @param {UpdatePlannedPaymentCommand} [updatePlannedPaymentCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPaymentsIdPut(id: string, updatePlannedPaymentCommand?: UpdatePlannedPaymentCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPaymentsIdPut(id, updatePlannedPaymentCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlannedPaymentApi.apiPaymentsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Создание платежа
         * @param {CreatePlannedPaymentCommand} [createPlannedPaymentCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPaymentsPost(createPlannedPaymentCommand?: CreatePlannedPaymentCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlannedPaymentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPaymentsPost(createPlannedPaymentCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlannedPaymentApi.apiPaymentsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PlannedPaymentApi - factory interface
 * @export
 */
export const PlannedPaymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlannedPaymentApiFp(configuration)
    return {
        /**
         * 
         * @summary Получение всех платежей
         * @param {string} [categoryId] Идентификатор категории
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Предел
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsGet(categoryId?: string, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<PlannedPaymentDtoPagedList> {
            return localVarFp.apiPaymentsGet(categoryId, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Удаление платежа
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiPaymentsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Получение платежа по ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DetailedPlannedPaymentDto> {
            return localVarFp.apiPaymentsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Обновление платежа
         * @param {string} id 
         * @param {UpdatePlannedPaymentCommand} [updatePlannedPaymentCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsIdPut(id: string, updatePlannedPaymentCommand?: UpdatePlannedPaymentCommand, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiPaymentsIdPut(id, updatePlannedPaymentCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Создание платежа
         * @param {CreatePlannedPaymentCommand} [createPlannedPaymentCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsPost(createPlannedPaymentCommand?: CreatePlannedPaymentCommand, options?: RawAxiosRequestConfig): AxiosPromise<PlannedPaymentDto> {
            return localVarFp.apiPaymentsPost(createPlannedPaymentCommand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlannedPaymentApi - object-oriented interface
 * @export
 * @class PlannedPaymentApi
 * @extends {BaseAPI}
 */
export class PlannedPaymentApi extends BaseAPI {
    /**
     * 
     * @summary Получение всех платежей
     * @param {string} [categoryId] Идентификатор категории
     * @param {number} [page] Номер страницы
     * @param {number} [limit] Предел
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlannedPaymentApi
     */
    public apiPaymentsGet(categoryId?: string, page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return PlannedPaymentApiFp(this.configuration).apiPaymentsGet(categoryId, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Удаление платежа
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlannedPaymentApi
     */
    public apiPaymentsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return PlannedPaymentApiFp(this.configuration).apiPaymentsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Получение платежа по ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlannedPaymentApi
     */
    public apiPaymentsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return PlannedPaymentApiFp(this.configuration).apiPaymentsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Обновление платежа
     * @param {string} id 
     * @param {UpdatePlannedPaymentCommand} [updatePlannedPaymentCommand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlannedPaymentApi
     */
    public apiPaymentsIdPut(id: string, updatePlannedPaymentCommand?: UpdatePlannedPaymentCommand, options?: RawAxiosRequestConfig) {
        return PlannedPaymentApiFp(this.configuration).apiPaymentsIdPut(id, updatePlannedPaymentCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Создание платежа
     * @param {CreatePlannedPaymentCommand} [createPlannedPaymentCommand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlannedPaymentApi
     */
    public apiPaymentsPost(createPlannedPaymentCommand?: CreatePlannedPaymentCommand, options?: RawAxiosRequestConfig) {
        return PlannedPaymentApiFp(this.configuration).apiPaymentsPost(createPlannedPaymentCommand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransactionApi - axios parameter creator
 * @export
 */
export const TransactionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Получение всех транзакций
         * @param {string} [categoryId] Идентификатор категории
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Предел
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsGet: async (categoryId?: string, page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (categoryId !== undefined) {
                localVarQueryParameter['category_id'] = categoryId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Удаление транзакции
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiTransactionsIdDelete', 'id', id)
            const localVarPath = `/api/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Получение транзакции по ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiTransactionsIdGet', 'id', id)
            const localVarPath = `/api/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Обновление транзакции
         * @param {string} id 
         * @param {UpdateTransactionCommand} [updateTransactionCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsIdPut: async (id: string, updateTransactionCommand?: UpdateTransactionCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiTransactionsIdPut', 'id', id)
            const localVarPath = `/api/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTransactionCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Создание транзакции
         * @param {CreateTransactionCommand} [createTransactionCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsPost: async (createTransactionCommand?: CreateTransactionCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTransactionCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionApi - functional programming interface
 * @export
 */
export const TransactionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Получение всех транзакций
         * @param {string} [categoryId] Идентификатор категории
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Предел
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsGet(categoryId?: string, page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDtoPagedList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsGet(categoryId, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.apiTransactionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Удаление транзакции
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.apiTransactionsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Получение транзакции по ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedTransactionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.apiTransactionsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Обновление транзакции
         * @param {string} id 
         * @param {UpdateTransactionCommand} [updateTransactionCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsIdPut(id: string, updateTransactionCommand?: UpdateTransactionCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsIdPut(id, updateTransactionCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.apiTransactionsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Создание транзакции
         * @param {CreateTransactionCommand} [createTransactionCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsPost(createTransactionCommand?: CreateTransactionCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsPost(createTransactionCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.apiTransactionsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TransactionApi - factory interface
 * @export
 */
export const TransactionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionApiFp(configuration)
    return {
        /**
         * 
         * @summary Получение всех транзакций
         * @param {string} [categoryId] Идентификатор категории
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Предел
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsGet(categoryId?: string, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<TransactionDtoPagedList> {
            return localVarFp.apiTransactionsGet(categoryId, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Удаление транзакции
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiTransactionsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Получение транзакции по ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DetailedTransactionDto> {
            return localVarFp.apiTransactionsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Обновление транзакции
         * @param {string} id 
         * @param {UpdateTransactionCommand} [updateTransactionCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsIdPut(id: string, updateTransactionCommand?: UpdateTransactionCommand, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiTransactionsIdPut(id, updateTransactionCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Создание транзакции
         * @param {CreateTransactionCommand} [createTransactionCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsPost(createTransactionCommand?: CreateTransactionCommand, options?: RawAxiosRequestConfig): AxiosPromise<TransactionDto> {
            return localVarFp.apiTransactionsPost(createTransactionCommand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionApi - object-oriented interface
 * @export
 * @class TransactionApi
 * @extends {BaseAPI}
 */
export class TransactionApi extends BaseAPI {
    /**
     * 
     * @summary Получение всех транзакций
     * @param {string} [categoryId] Идентификатор категории
     * @param {number} [page] Номер страницы
     * @param {number} [limit] Предел
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public apiTransactionsGet(categoryId?: string, page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).apiTransactionsGet(categoryId, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Удаление транзакции
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public apiTransactionsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).apiTransactionsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Получение транзакции по ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public apiTransactionsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).apiTransactionsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Обновление транзакции
     * @param {string} id 
     * @param {UpdateTransactionCommand} [updateTransactionCommand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public apiTransactionsIdPut(id: string, updateTransactionCommand?: UpdateTransactionCommand, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).apiTransactionsIdPut(id, updateTransactionCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Создание транзакции
     * @param {CreateTransactionCommand} [createTransactionCommand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public apiTransactionsPost(createTransactionCommand?: CreateTransactionCommand, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).apiTransactionsPost(createTransactionCommand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Получить профиль текущего пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersProfileGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Получить профиль текущего пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersProfileGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersProfileGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersProfileGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Получить профиль текущего пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersProfileGet(options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.apiUsersProfileGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Получить профиль текущего пользователя
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersProfileGet(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersProfileGet(options).then((request) => request(this.axios, this.basePath));
    }
}



