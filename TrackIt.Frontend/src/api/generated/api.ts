/* tslint:disable */
/* eslint-disable */
/**
 * TrackIt API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Animation
 */
export interface Animation {
    /**
     * 
     * @type {string}
     * @memberof Animation
     */
    'fileId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Animation
     */
    'fileUniqueId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Animation
     */
    'fileSize'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Animation
     */
    'width'?: number;
    /**
     * 
     * @type {number}
     * @memberof Animation
     */
    'height'?: number;
    /**
     * 
     * @type {number}
     * @memberof Animation
     */
    'duration'?: number;
    /**
     * 
     * @type {PhotoSize}
     * @memberof Animation
     */
    'thumbnail'?: PhotoSize;
    /**
     * 
     * @type {string}
     * @memberof Animation
     */
    'fileName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Animation
     */
    'mimeType'?: string | null;
}
/**
 * 
 * @export
 * @interface Audio
 */
export interface Audio {
    /**
     * 
     * @type {string}
     * @memberof Audio
     */
    'fileId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Audio
     */
    'fileUniqueId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Audio
     */
    'fileSize'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Audio
     */
    'duration'?: number;
    /**
     * 
     * @type {string}
     * @memberof Audio
     */
    'performer'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Audio
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Audio
     */
    'fileName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Audio
     */
    'mimeType'?: string | null;
    /**
     * 
     * @type {PhotoSize}
     * @memberof Audio
     */
    'thumbnail'?: PhotoSize;
}
/**
 * 
 * @export
 * @interface BackgroundType
 */
export interface BackgroundType {
    /**
     * 
     * @type {BackgroundTypeKind}
     * @memberof BackgroundType
     */
    'type'?: BackgroundTypeKind;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const BackgroundTypeKind = {
    Fill: 'fill',
    Wallpaper: 'wallpaper',
    Pattern: 'pattern',
    ChatTheme: 'chat_theme'
} as const;

export type BackgroundTypeKind = typeof BackgroundTypeKind[keyof typeof BackgroundTypeKind];


/**
 * Модель общего баланса
 * @export
 * @interface BalanceDto
 */
export interface BalanceDto {
    /**
     * Сумма всех доходов
     * @type {number}
     * @memberof BalanceDto
     */
    'total_income'?: number;
    /**
     * Сумма всех расходов
     * @type {number}
     * @memberof BalanceDto
     */
    'total_expense'?: number;
    /**
     * Баланс
     * @type {number}
     * @memberof BalanceDto
     */
    'balance'?: number;
}
/**
 * Модель лимита бюджета
 * @export
 * @interface BudgetDto
 */
export interface BudgetDto {
    /**
     * Уникальный идентификатор
     * @type {string}
     * @memberof BudgetDto
     */
    'id'?: string;
    /**
     * Величина лимита
     * @type {number}
     * @memberof BudgetDto
     */
    'amount'?: number;
    /**
     * Идентификатор категории
     * @type {string}
     * @memberof BudgetDto
     */
    'category_id'?: string | null;
}
/**
 * Пагинированный список
 * @export
 * @interface BudgetDtoPagedList
 */
export interface BudgetDtoPagedList {
    /**
     * Элементы
     * @type {Array<BudgetDto>}
     * @memberof BudgetDtoPagedList
     */
    'items'?: Array<BudgetDto> | null;
    /**
     * Всего элементов
     * @type {number}
     * @memberof BudgetDtoPagedList
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface BusinessConnection
 */
export interface BusinessConnection {
    /**
     * 
     * @type {string}
     * @memberof BusinessConnection
     */
    'id'?: string | null;
    /**
     * 
     * @type {User}
     * @memberof BusinessConnection
     */
    'user'?: User;
    /**
     * 
     * @type {number}
     * @memberof BusinessConnection
     */
    'userChatId'?: number;
    /**
     * 
     * @type {string}
     * @memberof BusinessConnection
     */
    'date'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BusinessConnection
     */
    'canReply'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BusinessConnection
     */
    'isEnabled'?: boolean;
}
/**
 * 
 * @export
 * @interface BusinessMessagesDeleted
 */
export interface BusinessMessagesDeleted {
    /**
     * 
     * @type {string}
     * @memberof BusinessMessagesDeleted
     */
    'businessConnectionId'?: string | null;
    /**
     * 
     * @type {Chat}
     * @memberof BusinessMessagesDeleted
     */
    'chat'?: Chat;
    /**
     * 
     * @type {Array<number>}
     * @memberof BusinessMessagesDeleted
     */
    'messageIds'?: Array<number> | null;
}
/**
 * 
 * @export
 * @interface CallbackQuery
 */
export interface CallbackQuery {
    /**
     * 
     * @type {string}
     * @memberof CallbackQuery
     */
    'id'?: string | null;
    /**
     * 
     * @type {User}
     * @memberof CallbackQuery
     */
    'from'?: User;
    /**
     * 
     * @type {Message}
     * @memberof CallbackQuery
     */
    'message'?: Message;
    /**
     * 
     * @type {string}
     * @memberof CallbackQuery
     */
    'inlineMessageId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CallbackQuery
     */
    'chatInstance'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CallbackQuery
     */
    'data'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CallbackQuery
     */
    'gameShortName'?: string | null;
}
/**
 * Модель категории
 * @export
 * @interface CategoryDto
 */
export interface CategoryDto {
    /**
     * Уникальный идентификатор категории
     * @type {string}
     * @memberof CategoryDto
     */
    'id'?: string;
    /**
     * Название категории
     * @type {string}
     * @memberof CategoryDto
     */
    'name'?: string | null;
    /**
     * 
     * @type {CategoryType}
     * @memberof CategoryDto
     */
    'type'?: CategoryType;
    /**
     * Идентификатор пользователя
     * @type {string}
     * @memberof CategoryDto
     */
    'user_id'?: string;
}


/**
 * Пагинированный список
 * @export
 * @interface CategoryDtoPagedList
 */
export interface CategoryDtoPagedList {
    /**
     * Элементы
     * @type {Array<CategoryDto>}
     * @memberof CategoryDtoPagedList
     */
    'items'?: Array<CategoryDto> | null;
    /**
     * Всего элементов
     * @type {number}
     * @memberof CategoryDtoPagedList
     */
    'total'?: number;
}
/**
 * Модель траты по категории
 * @export
 * @interface CategorySpendingDto
 */
export interface CategorySpendingDto {
    /**
     * Название категории
     * @type {string}
     * @memberof CategorySpendingDto
     */
    'category'?: string | null;
    /**
     * Всего потрачено
     * @type {number}
     * @memberof CategorySpendingDto
     */
    'total_spent'?: number;
}
/**
 * Тип категории
 * @export
 * @enum {number}
 */

export const CategoryType = {
    NUMBER_1: 1,
    NUMBER_MINUS_1: -1
} as const;

export type CategoryType = typeof CategoryType[keyof typeof CategoryType];


/**
 * 
 * @export
 * @interface Chat
 */
export interface Chat {
    /**
     * 
     * @type {number}
     * @memberof Chat
     */
    'id'?: number;
    /**
     * 
     * @type {ChatType}
     * @memberof Chat
     */
    'type'?: ChatType;
    /**
     * 
     * @type {string}
     * @memberof Chat
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Chat
     */
    'username'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Chat
     */
    'firstName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Chat
     */
    'lastName'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Chat
     */
    'isForum'?: boolean;
}


/**
 * 
 * @export
 * @interface ChatBackground
 */
export interface ChatBackground {
    /**
     * 
     * @type {BackgroundType}
     * @memberof ChatBackground
     */
    'type'?: BackgroundType;
}
/**
 * 
 * @export
 * @interface ChatBoost
 */
export interface ChatBoost {
    /**
     * 
     * @type {string}
     * @memberof ChatBoost
     */
    'boostId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatBoost
     */
    'addDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatBoost
     */
    'expirationDate'?: string;
    /**
     * 
     * @type {ChatBoostSource}
     * @memberof ChatBoost
     */
    'source'?: ChatBoostSource;
}
/**
 * 
 * @export
 * @interface ChatBoostAdded
 */
export interface ChatBoostAdded {
    /**
     * 
     * @type {number}
     * @memberof ChatBoostAdded
     */
    'boostCount'?: number;
}
/**
 * 
 * @export
 * @interface ChatBoostRemoved
 */
export interface ChatBoostRemoved {
    /**
     * 
     * @type {Chat}
     * @memberof ChatBoostRemoved
     */
    'chat'?: Chat;
    /**
     * 
     * @type {string}
     * @memberof ChatBoostRemoved
     */
    'boostId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatBoostRemoved
     */
    'removeDate'?: string;
    /**
     * 
     * @type {ChatBoostSource}
     * @memberof ChatBoostRemoved
     */
    'source'?: ChatBoostSource;
}
/**
 * 
 * @export
 * @interface ChatBoostSource
 */
export interface ChatBoostSource {
    /**
     * 
     * @type {ChatBoostSourceType}
     * @memberof ChatBoostSource
     */
    'source'?: ChatBoostSourceType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ChatBoostSourceType = {
    Premium: 'premium',
    GiftCode: 'gift_code',
    Giveaway: 'giveaway'
} as const;

export type ChatBoostSourceType = typeof ChatBoostSourceType[keyof typeof ChatBoostSourceType];


/**
 * 
 * @export
 * @interface ChatBoostUpdated
 */
export interface ChatBoostUpdated {
    /**
     * 
     * @type {Chat}
     * @memberof ChatBoostUpdated
     */
    'chat'?: Chat;
    /**
     * 
     * @type {ChatBoost}
     * @memberof ChatBoostUpdated
     */
    'boost'?: ChatBoost;
}
/**
 * 
 * @export
 * @interface ChatInviteLink
 */
export interface ChatInviteLink {
    /**
     * 
     * @type {string}
     * @memberof ChatInviteLink
     */
    'inviteLink'?: string | null;
    /**
     * 
     * @type {User}
     * @memberof ChatInviteLink
     */
    'creator'?: User;
    /**
     * 
     * @type {boolean}
     * @memberof ChatInviteLink
     */
    'createsJoinRequest'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ChatInviteLink
     */
    'isPrimary'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ChatInviteLink
     */
    'isRevoked'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ChatInviteLink
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatInviteLink
     */
    'expireDate'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ChatInviteLink
     */
    'memberLimit'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ChatInviteLink
     */
    'pendingJoinRequestCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ChatInviteLink
     */
    'subscriptionPeriod'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ChatInviteLink
     */
    'subscriptionPrice'?: number | null;
}
/**
 * 
 * @export
 * @interface ChatJoinRequest
 */
export interface ChatJoinRequest {
    /**
     * 
     * @type {Chat}
     * @memberof ChatJoinRequest
     */
    'chat'?: Chat;
    /**
     * 
     * @type {User}
     * @memberof ChatJoinRequest
     */
    'from'?: User;
    /**
     * 
     * @type {number}
     * @memberof ChatJoinRequest
     */
    'userChatId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ChatJoinRequest
     */
    'date'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatJoinRequest
     */
    'bio'?: string | null;
    /**
     * 
     * @type {ChatInviteLink}
     * @memberof ChatJoinRequest
     */
    'inviteLink'?: ChatInviteLink;
}
/**
 * 
 * @export
 * @interface ChatMember
 */
export interface ChatMember {
    /**
     * 
     * @type {ChatMemberStatus}
     * @memberof ChatMember
     */
    'status'?: ChatMemberStatus;
    /**
     * 
     * @type {User}
     * @memberof ChatMember
     */
    'user'?: User;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ChatMemberStatus = {
    Creator: 'creator',
    Administrator: 'administrator',
    Member: 'member',
    Left: 'left',
    Kicked: 'kicked',
    Restricted: 'restricted'
} as const;

export type ChatMemberStatus = typeof ChatMemberStatus[keyof typeof ChatMemberStatus];


/**
 * 
 * @export
 * @interface ChatMemberUpdated
 */
export interface ChatMemberUpdated {
    /**
     * 
     * @type {Chat}
     * @memberof ChatMemberUpdated
     */
    'chat'?: Chat;
    /**
     * 
     * @type {User}
     * @memberof ChatMemberUpdated
     */
    'from'?: User;
    /**
     * 
     * @type {string}
     * @memberof ChatMemberUpdated
     */
    'date'?: string;
    /**
     * 
     * @type {ChatMember}
     * @memberof ChatMemberUpdated
     */
    'oldChatMember'?: ChatMember;
    /**
     * 
     * @type {ChatMember}
     * @memberof ChatMemberUpdated
     */
    'newChatMember'?: ChatMember;
    /**
     * 
     * @type {ChatInviteLink}
     * @memberof ChatMemberUpdated
     */
    'inviteLink'?: ChatInviteLink;
    /**
     * 
     * @type {boolean}
     * @memberof ChatMemberUpdated
     */
    'viaJoinRequest'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ChatMemberUpdated
     */
    'viaChatFolderInviteLink'?: boolean;
}
/**
 * 
 * @export
 * @interface ChatShared
 */
export interface ChatShared {
    /**
     * 
     * @type {number}
     * @memberof ChatShared
     */
    'requestId'?: number;
    /**
     * 
     * @type {number}
     * @memberof ChatShared
     */
    'chatId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ChatShared
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatShared
     */
    'username'?: string | null;
    /**
     * 
     * @type {Array<PhotoSize>}
     * @memberof ChatShared
     */
    'photo'?: Array<PhotoSize> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ChatType = {
    Private: 'private',
    Group: 'group',
    Channel: 'channel',
    Supergroup: 'supergroup',
    Sender: 'sender'
} as const;

export type ChatType = typeof ChatType[keyof typeof ChatType];


/**
 * 
 * @export
 * @interface ChosenInlineResult
 */
export interface ChosenInlineResult {
    /**
     * 
     * @type {string}
     * @memberof ChosenInlineResult
     */
    'resultId'?: string | null;
    /**
     * 
     * @type {User}
     * @memberof ChosenInlineResult
     */
    'from'?: User;
    /**
     * 
     * @type {Location}
     * @memberof ChosenInlineResult
     */
    'location'?: Location;
    /**
     * 
     * @type {string}
     * @memberof ChosenInlineResult
     */
    'inlineMessageId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChosenInlineResult
     */
    'query'?: string | null;
}
/**
 * 
 * @export
 * @interface Contact
 */
export interface Contact {
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'phoneNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'firstName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'lastName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Contact
     */
    'userId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'vcard'?: string | null;
}
/**
 * 
 * @export
 * @interface CopyTextButton
 */
export interface CopyTextButton {
    /**
     * 
     * @type {string}
     * @memberof CopyTextButton
     */
    'text'?: string | null;
}
/**
 * Запрос на создание запланированного платежа
 * @export
 * @interface CreateBudgetCommand
 */
export interface CreateBudgetCommand {
    /**
     * Идентификатор категории
     * @type {string}
     * @memberof CreateBudgetCommand
     */
    'category_id'?: string;
    /**
     * Величина лимита
     * @type {number}
     * @memberof CreateBudgetCommand
     */
    'amount'?: number;
}
/**
 * Запрос на создание категории
 * @export
 * @interface CreateCategoryCommand
 */
export interface CreateCategoryCommand {
    /**
     * Название категории
     * @type {string}
     * @memberof CreateCategoryCommand
     */
    'name'?: string | null;
    /**
     * 
     * @type {CategoryType}
     * @memberof CreateCategoryCommand
     */
    'type'?: CategoryType;
}


/**
 * Запрос на создание запланированного платежа
 * @export
 * @interface CreatePlannedPaymentCommand
 */
export interface CreatePlannedPaymentCommand {
    /**
     * Идентификатор категории
     * @type {string}
     * @memberof CreatePlannedPaymentCommand
     */
    'category_id'?: string;
    /**
     * Объем оплаты
     * @type {number}
     * @memberof CreatePlannedPaymentCommand
     */
    'amount'?: number;
    /**
     * Дата
     * @type {string}
     * @memberof CreatePlannedPaymentCommand
     */
    'due_date'?: string;
    /**
     * Описание
     * @type {string}
     * @memberof CreatePlannedPaymentCommand
     */
    'description'?: string | null;
}
/**
 * Команда для создания новой транзакции.
 * @export
 * @interface CreateTransactionCommand
 */
export interface CreateTransactionCommand {
    /**
     * Идентификатор категории.
     * @type {string}
     * @memberof CreateTransactionCommand
     */
    'category_id'?: string;
    /**
     * Сумма транзакции.
     * @type {number}
     * @memberof CreateTransactionCommand
     */
    'amount'?: number;
    /**
     * Описание транзакции.
     * @type {string}
     * @memberof CreateTransactionCommand
     */
    'description'?: string | null;
    /**
     * Дата транзакции.
     * @type {string}
     * @memberof CreateTransactionCommand
     */
    'date'?: string;
}
/**
 * Модель дневных трат
 * @export
 * @interface DailySpendingDto
 */
export interface DailySpendingDto {
    /**
     * Номер дня
     * @type {number}
     * @memberof DailySpendingDto
     */
    'day'?: number;
    /**
     * Всего потрачено
     * @type {number}
     * @memberof DailySpendingDto
     */
    'total_spent'?: number;
}
/**
 * Детализированная модель лимита бюджета
 * @export
 * @interface DetailedBudgetDto
 */
export interface DetailedBudgetDto {
    /**
     * Уникальный идентификатор
     * @type {string}
     * @memberof DetailedBudgetDto
     */
    'id'?: string;
    /**
     * Величина лимита
     * @type {number}
     * @memberof DetailedBudgetDto
     */
    'amount'?: number;
    /**
     * Идентификатор категории
     * @type {string}
     * @memberof DetailedBudgetDto
     */
    'category_id'?: string | null;
    /**
     * Дата создания
     * @type {string}
     * @memberof DetailedBudgetDto
     */
    'created_at'?: string;
    /**
     * Дата обновления
     * @type {string}
     * @memberof DetailedBudgetDto
     */
    'updated_at'?: string;
}
/**
 * Детализированная модель категории
 * @export
 * @interface DetailedCategoryDto
 */
export interface DetailedCategoryDto {
    /**
     * Уникальный идентификатор категории
     * @type {string}
     * @memberof DetailedCategoryDto
     */
    'id'?: string;
    /**
     * Название категории
     * @type {string}
     * @memberof DetailedCategoryDto
     */
    'name'?: string | null;
    /**
     * 
     * @type {CategoryType}
     * @memberof DetailedCategoryDto
     */
    'type'?: CategoryType;
    /**
     * Идентификатор пользователя
     * @type {string}
     * @memberof DetailedCategoryDto
     */
    'user_id'?: string;
    /**
     * Дата создания
     * @type {string}
     * @memberof DetailedCategoryDto
     */
    'created_at'?: string;
    /**
     * Дата обновления
     * @type {string}
     * @memberof DetailedCategoryDto
     */
    'updated_at'?: string;
}


/**
 * Детализированная модель запланированной платы
 * @export
 * @interface DetailedPlannedPaymentDto
 */
export interface DetailedPlannedPaymentDto {
    /**
     * Уникальный идентификатор
     * @type {string}
     * @memberof DetailedPlannedPaymentDto
     */
    'id'?: string;
    /**
     * Объем оплаты
     * @type {number}
     * @memberof DetailedPlannedPaymentDto
     */
    'amount'?: number;
    /**
     * Дата
     * @type {string}
     * @memberof DetailedPlannedPaymentDto
     */
    'due_date'?: string;
    /**
     * Идентификатор категории
     * @type {string}
     * @memberof DetailedPlannedPaymentDto
     */
    'category_id'?: string | null;
    /**
     * Описание
     * @type {string}
     * @memberof DetailedPlannedPaymentDto
     */
    'description'?: string | null;
    /**
     * Дата создания
     * @type {string}
     * @memberof DetailedPlannedPaymentDto
     */
    'created_at'?: string;
    /**
     * Дата обновления
     * @type {string}
     * @memberof DetailedPlannedPaymentDto
     */
    'updated_at'?: string;
}
/**
 * Детализированная модель транзакции
 * @export
 * @interface DetailedTransactionDto
 */
export interface DetailedTransactionDto {
    /**
     * Уникальный идентификатор транзакции.
     * @type {string}
     * @memberof DetailedTransactionDto
     */
    'id'?: string;
    /**
     * Уникальный идентификатор пользователя.
     * @type {string}
     * @memberof DetailedTransactionDto
     */
    'user_id'?: string;
    /**
     * Сумма транзакции.
     * @type {number}
     * @memberof DetailedTransactionDto
     */
    'amount'?: number;
    /**
     * Дата транзакции.
     * @type {string}
     * @memberof DetailedTransactionDto
     */
    'date'?: string;
    /**
     * Дата создания
     * @type {string}
     * @memberof DetailedTransactionDto
     */
    'created_at'?: string;
    /**
     * Дата обновления
     * @type {string}
     * @memberof DetailedTransactionDto
     */
    'updated_at'?: string;
    /**
     * Описание
     * @type {string}
     * @memberof DetailedTransactionDto
     */
    'description'?: string | null;
    /**
     * Идентификатор категории
     * @type {string}
     * @memberof DetailedTransactionDto
     */
    'category_id'?: string | null;
}
/**
 * 
 * @export
 * @interface Dice
 */
export interface Dice {
    /**
     * 
     * @type {string}
     * @memberof Dice
     */
    'emoji'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Dice
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface Document
 */
export interface Document {
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'fileId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'fileUniqueId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'fileSize'?: number | null;
    /**
     * 
     * @type {PhotoSize}
     * @memberof Document
     */
    'thumbnail'?: PhotoSize;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'fileName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'mimeType'?: string | null;
}
/**
 * 
 * @export
 * @interface EncryptedCredentials
 */
export interface EncryptedCredentials {
    /**
     * 
     * @type {string}
     * @memberof EncryptedCredentials
     */
    'data'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EncryptedCredentials
     */
    'hash'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EncryptedCredentials
     */
    'secret'?: string | null;
}
/**
 * 
 * @export
 * @interface EncryptedPassportElement
 */
export interface EncryptedPassportElement {
    /**
     * 
     * @type {EncryptedPassportElementType}
     * @memberof EncryptedPassportElement
     */
    'type'?: EncryptedPassportElementType;
    /**
     * 
     * @type {string}
     * @memberof EncryptedPassportElement
     */
    'data'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EncryptedPassportElement
     */
    'phoneNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EncryptedPassportElement
     */
    'email'?: string | null;
    /**
     * 
     * @type {Array<PassportFile>}
     * @memberof EncryptedPassportElement
     */
    'files'?: Array<PassportFile> | null;
    /**
     * 
     * @type {PassportFile}
     * @memberof EncryptedPassportElement
     */
    'frontSide'?: PassportFile;
    /**
     * 
     * @type {PassportFile}
     * @memberof EncryptedPassportElement
     */
    'reverseSide'?: PassportFile;
    /**
     * 
     * @type {PassportFile}
     * @memberof EncryptedPassportElement
     */
    'selfie'?: PassportFile;
    /**
     * 
     * @type {Array<PassportFile>}
     * @memberof EncryptedPassportElement
     */
    'translation'?: Array<PassportFile> | null;
    /**
     * 
     * @type {string}
     * @memberof EncryptedPassportElement
     */
    'hash'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const EncryptedPassportElementType = {
    PersonalDetails: 'personal_details',
    Passport: 'passport',
    DriverLicense: 'driver_license',
    IdentityCard: 'identity_card',
    InternalPassport: 'internal_passport',
    Address: 'address',
    UtilityBill: 'utility_bill',
    BankStatement: 'bank_statement',
    RentalAgreement: 'rental_agreement',
    PassportRegistration: 'passport_registration',
    TemporaryRegistration: 'temporary_registration',
    PhoneNumber: 'phone_number',
    Email: 'email'
} as const;

export type EncryptedPassportElementType = typeof EncryptedPassportElementType[keyof typeof EncryptedPassportElementType];


/**
 * 
 * @export
 * @interface ExternalReplyInfo
 */
export interface ExternalReplyInfo {
    /**
     * 
     * @type {MessageOrigin}
     * @memberof ExternalReplyInfo
     */
    'origin'?: MessageOrigin;
    /**
     * 
     * @type {Chat}
     * @memberof ExternalReplyInfo
     */
    'chat'?: Chat;
    /**
     * 
     * @type {number}
     * @memberof ExternalReplyInfo
     */
    'messageId'?: number | null;
    /**
     * 
     * @type {LinkPreviewOptions}
     * @memberof ExternalReplyInfo
     */
    'linkPreviewOptions'?: LinkPreviewOptions;
    /**
     * 
     * @type {Animation}
     * @memberof ExternalReplyInfo
     */
    'animation'?: Animation;
    /**
     * 
     * @type {Audio}
     * @memberof ExternalReplyInfo
     */
    'audio'?: Audio;
    /**
     * 
     * @type {Document}
     * @memberof ExternalReplyInfo
     */
    'document'?: Document;
    /**
     * 
     * @type {PaidMediaInfo}
     * @memberof ExternalReplyInfo
     */
    'paidMedia'?: PaidMediaInfo;
    /**
     * 
     * @type {Array<PhotoSize>}
     * @memberof ExternalReplyInfo
     */
    'photo'?: Array<PhotoSize> | null;
    /**
     * 
     * @type {Sticker}
     * @memberof ExternalReplyInfo
     */
    'sticker'?: Sticker;
    /**
     * 
     * @type {Story}
     * @memberof ExternalReplyInfo
     */
    'story'?: Story;
    /**
     * 
     * @type {Video}
     * @memberof ExternalReplyInfo
     */
    'video'?: Video;
    /**
     * 
     * @type {VideoNote}
     * @memberof ExternalReplyInfo
     */
    'videoNote'?: VideoNote;
    /**
     * 
     * @type {Voice}
     * @memberof ExternalReplyInfo
     */
    'voice'?: Voice;
    /**
     * 
     * @type {boolean}
     * @memberof ExternalReplyInfo
     */
    'hasMediaSpoiler'?: boolean;
    /**
     * 
     * @type {Contact}
     * @memberof ExternalReplyInfo
     */
    'contact'?: Contact;
    /**
     * 
     * @type {Dice}
     * @memberof ExternalReplyInfo
     */
    'dice'?: Dice;
    /**
     * 
     * @type {Game}
     * @memberof ExternalReplyInfo
     */
    'game'?: Game;
    /**
     * 
     * @type {Giveaway}
     * @memberof ExternalReplyInfo
     */
    'giveaway'?: Giveaway;
    /**
     * 
     * @type {GiveawayWinners}
     * @memberof ExternalReplyInfo
     */
    'giveawayWinners'?: GiveawayWinners;
    /**
     * 
     * @type {Invoice}
     * @memberof ExternalReplyInfo
     */
    'invoice'?: Invoice;
    /**
     * 
     * @type {Location}
     * @memberof ExternalReplyInfo
     */
    'location'?: Location;
    /**
     * 
     * @type {Poll}
     * @memberof ExternalReplyInfo
     */
    'poll'?: Poll;
    /**
     * 
     * @type {Venue}
     * @memberof ExternalReplyInfo
     */
    'venue'?: Venue;
}
/**
 * 
 * @export
 * @interface ForumTopicCreated
 */
export interface ForumTopicCreated {
    /**
     * 
     * @type {string}
     * @memberof ForumTopicCreated
     */
    'name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ForumTopicCreated
     */
    'iconColor'?: number;
    /**
     * 
     * @type {string}
     * @memberof ForumTopicCreated
     */
    'iconCustomEmojiId'?: string | null;
}
/**
 * 
 * @export
 * @interface ForumTopicEdited
 */
export interface ForumTopicEdited {
    /**
     * 
     * @type {string}
     * @memberof ForumTopicEdited
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ForumTopicEdited
     */
    'iconCustomEmojiId'?: string | null;
}
/**
 * 
 * @export
 * @interface Game
 */
export interface Game {
    /**
     * 
     * @type {string}
     * @memberof Game
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Game
     */
    'description'?: string | null;
    /**
     * 
     * @type {Array<PhotoSize>}
     * @memberof Game
     */
    'photo'?: Array<PhotoSize> | null;
    /**
     * 
     * @type {string}
     * @memberof Game
     */
    'text'?: string | null;
    /**
     * 
     * @type {Array<MessageEntity>}
     * @memberof Game
     */
    'textEntities'?: Array<MessageEntity> | null;
    /**
     * 
     * @type {Animation}
     * @memberof Game
     */
    'animation'?: Animation;
}
/**
 * 
 * @export
 * @interface Giveaway
 */
export interface Giveaway {
    /**
     * 
     * @type {Array<Chat>}
     * @memberof Giveaway
     */
    'chats'?: Array<Chat> | null;
    /**
     * 
     * @type {string}
     * @memberof Giveaway
     */
    'winnersSelectionDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof Giveaway
     */
    'winnerCount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Giveaway
     */
    'onlyNewMembers'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Giveaway
     */
    'hasPublicWinners'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Giveaway
     */
    'prizeDescription'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Giveaway
     */
    'countryCodes'?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof Giveaway
     */
    'prizeStarCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Giveaway
     */
    'premiumSubscriptionMonthCount'?: number | null;
}
/**
 * 
 * @export
 * @interface GiveawayCompleted
 */
export interface GiveawayCompleted {
    /**
     * 
     * @type {number}
     * @memberof GiveawayCompleted
     */
    'winnerCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof GiveawayCompleted
     */
    'unclaimedPrizeCount'?: number | null;
    /**
     * 
     * @type {Message}
     * @memberof GiveawayCompleted
     */
    'giveawayMessage'?: Message;
    /**
     * 
     * @type {boolean}
     * @memberof GiveawayCompleted
     */
    'isStarGiveaway'?: boolean;
}
/**
 * 
 * @export
 * @interface GiveawayCreated
 */
export interface GiveawayCreated {
    /**
     * 
     * @type {number}
     * @memberof GiveawayCreated
     */
    'prizeStarCount'?: number | null;
}
/**
 * 
 * @export
 * @interface GiveawayWinners
 */
export interface GiveawayWinners {
    /**
     * 
     * @type {Chat}
     * @memberof GiveawayWinners
     */
    'chat'?: Chat;
    /**
     * 
     * @type {number}
     * @memberof GiveawayWinners
     */
    'giveawayMessageId'?: number;
    /**
     * 
     * @type {string}
     * @memberof GiveawayWinners
     */
    'winnersSelectionDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof GiveawayWinners
     */
    'winnerCount'?: number;
    /**
     * 
     * @type {Array<User>}
     * @memberof GiveawayWinners
     */
    'winners'?: Array<User> | null;
    /**
     * 
     * @type {number}
     * @memberof GiveawayWinners
     */
    'additionalChatCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GiveawayWinners
     */
    'prizeStarCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GiveawayWinners
     */
    'premiumSubscriptionMonthCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GiveawayWinners
     */
    'unclaimedPrizeCount'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof GiveawayWinners
     */
    'onlyNewMembers'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GiveawayWinners
     */
    'wasRefunded'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GiveawayWinners
     */
    'prizeDescription'?: string | null;
}
/**
 * 
 * @export
 * @interface InlineKeyboardButton
 */
export interface InlineKeyboardButton {
    /**
     * 
     * @type {string}
     * @memberof InlineKeyboardButton
     */
    'text'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineKeyboardButton
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineKeyboardButton
     */
    'callbackData'?: string | null;
    /**
     * 
     * @type {WebAppInfo}
     * @memberof InlineKeyboardButton
     */
    'webApp'?: WebAppInfo;
    /**
     * 
     * @type {LoginUrl}
     * @memberof InlineKeyboardButton
     */
    'loginUrl'?: LoginUrl;
    /**
     * 
     * @type {string}
     * @memberof InlineKeyboardButton
     */
    'switchInlineQuery'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineKeyboardButton
     */
    'switchInlineQueryCurrentChat'?: string | null;
    /**
     * 
     * @type {SwitchInlineQueryChosenChat}
     * @memberof InlineKeyboardButton
     */
    'switchInlineQueryChosenChat'?: SwitchInlineQueryChosenChat;
    /**
     * 
     * @type {CopyTextButton}
     * @memberof InlineKeyboardButton
     */
    'copyText'?: CopyTextButton;
    /**
     * 
     * @type {object}
     * @memberof InlineKeyboardButton
     */
    'callbackGame'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof InlineKeyboardButton
     */
    'pay'?: boolean;
}
/**
 * 
 * @export
 * @interface InlineKeyboardMarkup
 */
export interface InlineKeyboardMarkup {
    /**
     * 
     * @type {Array<Array<InlineKeyboardButton>>}
     * @memberof InlineKeyboardMarkup
     */
    'inlineKeyboard'?: Array<Array<InlineKeyboardButton>> | null;
}
/**
 * 
 * @export
 * @interface InlineQuery
 */
export interface InlineQuery {
    /**
     * 
     * @type {string}
     * @memberof InlineQuery
     */
    'id'?: string | null;
    /**
     * 
     * @type {User}
     * @memberof InlineQuery
     */
    'from'?: User;
    /**
     * 
     * @type {string}
     * @memberof InlineQuery
     */
    'query'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineQuery
     */
    'offset'?: string | null;
    /**
     * 
     * @type {ChatType}
     * @memberof InlineQuery
     */
    'chatType'?: ChatType;
    /**
     * 
     * @type {Location}
     * @memberof InlineQuery
     */
    'location'?: Location;
}


/**
 * 
 * @export
 * @interface Invoice
 */
export interface Invoice {
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'startParameter'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'currency'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'totalAmount'?: number;
}
/**
 * 
 * @export
 * @interface LinkPreviewOptions
 */
export interface LinkPreviewOptions {
    /**
     * 
     * @type {boolean}
     * @memberof LinkPreviewOptions
     */
    'isDisabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LinkPreviewOptions
     */
    'url'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof LinkPreviewOptions
     */
    'preferSmallMedia'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LinkPreviewOptions
     */
    'preferLargeMedia'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LinkPreviewOptions
     */
    'showAboveText'?: boolean;
}
/**
 * Прикрепить пользователя к Телеграм
 * @export
 * @interface LinkUserToTelegramCommand
 */
export interface LinkUserToTelegramCommand {
    /**
     * Код для привязки
     * @type {string}
     * @memberof LinkUserToTelegramCommand
     */
    'code'?: string | null;
}
/**
 * 
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * 
     * @type {number}
     * @memberof Location
     */
    'latitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof Location
     */
    'longitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof Location
     */
    'horizontalAccuracy'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Location
     */
    'livePeriod'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Location
     */
    'heading'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Location
     */
    'proximityAlertRadius'?: number | null;
}
/**
 * 
 * @export
 * @interface LoginUrl
 */
export interface LoginUrl {
    /**
     * 
     * @type {string}
     * @memberof LoginUrl
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LoginUrl
     */
    'forwardText'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LoginUrl
     */
    'botUsername'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof LoginUrl
     */
    'requestWriteAccess'?: boolean;
}
/**
 * 
 * @export
 * @interface MaskPosition
 */
export interface MaskPosition {
    /**
     * 
     * @type {MaskPositionPoint}
     * @memberof MaskPosition
     */
    'point'?: MaskPositionPoint;
    /**
     * 
     * @type {number}
     * @memberof MaskPosition
     */
    'xShift'?: number;
    /**
     * 
     * @type {number}
     * @memberof MaskPosition
     */
    'yShift'?: number;
    /**
     * 
     * @type {number}
     * @memberof MaskPosition
     */
    'scale'?: number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const MaskPositionPoint = {
    Forehead: 'forehead',
    Eyes: 'eyes',
    Mouth: 'mouth',
    Chin: 'chin'
} as const;

export type MaskPositionPoint = typeof MaskPositionPoint[keyof typeof MaskPositionPoint];


/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * 
     * @type {number}
     * @memberof Message
     */
    'message_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Message
     */
    'messageThreadId'?: number | null;
    /**
     * 
     * @type {User}
     * @memberof Message
     */
    'from'?: User;
    /**
     * 
     * @type {Chat}
     * @memberof Message
     */
    'senderChat'?: Chat;
    /**
     * 
     * @type {number}
     * @memberof Message
     */
    'senderBoostCount'?: number | null;
    /**
     * 
     * @type {User}
     * @memberof Message
     */
    'senderBusinessBot'?: User;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'date'?: string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'businessConnectionId'?: string | null;
    /**
     * 
     * @type {Chat}
     * @memberof Message
     */
    'chat'?: Chat;
    /**
     * 
     * @type {MessageOrigin}
     * @memberof Message
     */
    'forwardOrigin'?: MessageOrigin;
    /**
     * 
     * @type {boolean}
     * @memberof Message
     */
    'isTopicMessage'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Message
     */
    'isAutomaticForward'?: boolean;
    /**
     * 
     * @type {Message}
     * @memberof Message
     */
    'replyToMessage'?: Message;
    /**
     * 
     * @type {ExternalReplyInfo}
     * @memberof Message
     */
    'externalReply'?: ExternalReplyInfo;
    /**
     * 
     * @type {TextQuote}
     * @memberof Message
     */
    'quote'?: TextQuote;
    /**
     * 
     * @type {Story}
     * @memberof Message
     */
    'replyToStory'?: Story;
    /**
     * 
     * @type {User}
     * @memberof Message
     */
    'viaBot'?: User;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'editDate'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Message
     */
    'hasProtectedContent'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Message
     */
    'isFromOffline'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'mediaGroupId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'authorSignature'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'text'?: string | null;
    /**
     * 
     * @type {Array<MessageEntity>}
     * @memberof Message
     */
    'entities'?: Array<MessageEntity> | null;
    /**
     * 
     * @type {LinkPreviewOptions}
     * @memberof Message
     */
    'linkPreviewOptions'?: LinkPreviewOptions;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'effectId'?: string | null;
    /**
     * 
     * @type {Animation}
     * @memberof Message
     */
    'animation'?: Animation;
    /**
     * 
     * @type {Audio}
     * @memberof Message
     */
    'audio'?: Audio;
    /**
     * 
     * @type {Document}
     * @memberof Message
     */
    'document'?: Document;
    /**
     * 
     * @type {PaidMediaInfo}
     * @memberof Message
     */
    'paidMedia'?: PaidMediaInfo;
    /**
     * 
     * @type {Array<PhotoSize>}
     * @memberof Message
     */
    'photo'?: Array<PhotoSize> | null;
    /**
     * 
     * @type {Sticker}
     * @memberof Message
     */
    'sticker'?: Sticker;
    /**
     * 
     * @type {Story}
     * @memberof Message
     */
    'story'?: Story;
    /**
     * 
     * @type {Video}
     * @memberof Message
     */
    'video'?: Video;
    /**
     * 
     * @type {VideoNote}
     * @memberof Message
     */
    'videoNote'?: VideoNote;
    /**
     * 
     * @type {Voice}
     * @memberof Message
     */
    'voice'?: Voice;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'caption'?: string | null;
    /**
     * 
     * @type {Array<MessageEntity>}
     * @memberof Message
     */
    'captionEntities'?: Array<MessageEntity> | null;
    /**
     * 
     * @type {boolean}
     * @memberof Message
     */
    'showCaptionAboveMedia'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Message
     */
    'hasMediaSpoiler'?: boolean;
    /**
     * 
     * @type {Contact}
     * @memberof Message
     */
    'contact'?: Contact;
    /**
     * 
     * @type {Dice}
     * @memberof Message
     */
    'dice'?: Dice;
    /**
     * 
     * @type {Game}
     * @memberof Message
     */
    'game'?: Game;
    /**
     * 
     * @type {Poll}
     * @memberof Message
     */
    'poll'?: Poll;
    /**
     * 
     * @type {Venue}
     * @memberof Message
     */
    'venue'?: Venue;
    /**
     * 
     * @type {Location}
     * @memberof Message
     */
    'location'?: Location;
    /**
     * 
     * @type {Array<User>}
     * @memberof Message
     */
    'newChatMembers'?: Array<User> | null;
    /**
     * 
     * @type {User}
     * @memberof Message
     */
    'leftChatMember'?: User;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'newChatTitle'?: string | null;
    /**
     * 
     * @type {Array<PhotoSize>}
     * @memberof Message
     */
    'newChatPhoto'?: Array<PhotoSize> | null;
    /**
     * 
     * @type {boolean}
     * @memberof Message
     */
    'deleteChatPhoto'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof Message
     */
    'groupChatCreated'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof Message
     */
    'supergroupChatCreated'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof Message
     */
    'channelChatCreated'?: boolean | null;
    /**
     * 
     * @type {MessageAutoDeleteTimerChanged}
     * @memberof Message
     */
    'messageAutoDeleteTimerChanged'?: MessageAutoDeleteTimerChanged;
    /**
     * 
     * @type {number}
     * @memberof Message
     */
    'migrateToChatId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Message
     */
    'migrateFromChatId'?: number | null;
    /**
     * 
     * @type {Message}
     * @memberof Message
     */
    'pinnedMessage'?: Message;
    /**
     * 
     * @type {Invoice}
     * @memberof Message
     */
    'invoice'?: Invoice;
    /**
     * 
     * @type {SuccessfulPayment}
     * @memberof Message
     */
    'successfulPayment'?: SuccessfulPayment;
    /**
     * 
     * @type {RefundedPayment}
     * @memberof Message
     */
    'refundedPayment'?: RefundedPayment;
    /**
     * 
     * @type {UsersShared}
     * @memberof Message
     */
    'usersShared'?: UsersShared;
    /**
     * 
     * @type {ChatShared}
     * @memberof Message
     */
    'chatShared'?: ChatShared;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'connectedWebsite'?: string | null;
    /**
     * 
     * @type {WriteAccessAllowed}
     * @memberof Message
     */
    'writeAccessAllowed'?: WriteAccessAllowed;
    /**
     * 
     * @type {PassportData}
     * @memberof Message
     */
    'passportData'?: PassportData;
    /**
     * 
     * @type {ProximityAlertTriggered}
     * @memberof Message
     */
    'proximityAlertTriggered'?: ProximityAlertTriggered;
    /**
     * 
     * @type {ChatBoostAdded}
     * @memberof Message
     */
    'boostAdded'?: ChatBoostAdded;
    /**
     * 
     * @type {ChatBackground}
     * @memberof Message
     */
    'chatBackgroundSet'?: ChatBackground;
    /**
     * 
     * @type {ForumTopicCreated}
     * @memberof Message
     */
    'forumTopicCreated'?: ForumTopicCreated;
    /**
     * 
     * @type {ForumTopicEdited}
     * @memberof Message
     */
    'forumTopicEdited'?: ForumTopicEdited;
    /**
     * 
     * @type {object}
     * @memberof Message
     */
    'forumTopicClosed'?: object;
    /**
     * 
     * @type {object}
     * @memberof Message
     */
    'forumTopicReopened'?: object;
    /**
     * 
     * @type {object}
     * @memberof Message
     */
    'generalForumTopicHidden'?: object;
    /**
     * 
     * @type {object}
     * @memberof Message
     */
    'generalForumTopicUnhidden'?: object;
    /**
     * 
     * @type {GiveawayCreated}
     * @memberof Message
     */
    'giveawayCreated'?: GiveawayCreated;
    /**
     * 
     * @type {Giveaway}
     * @memberof Message
     */
    'giveaway'?: Giveaway;
    /**
     * 
     * @type {GiveawayWinners}
     * @memberof Message
     */
    'giveawayWinners'?: GiveawayWinners;
    /**
     * 
     * @type {GiveawayCompleted}
     * @memberof Message
     */
    'giveawayCompleted'?: GiveawayCompleted;
    /**
     * 
     * @type {VideoChatScheduled}
     * @memberof Message
     */
    'videoChatScheduled'?: VideoChatScheduled;
    /**
     * 
     * @type {object}
     * @memberof Message
     */
    'videoChatStarted'?: object;
    /**
     * 
     * @type {VideoChatEnded}
     * @memberof Message
     */
    'videoChatEnded'?: VideoChatEnded;
    /**
     * 
     * @type {VideoChatParticipantsInvited}
     * @memberof Message
     */
    'videoChatParticipantsInvited'?: VideoChatParticipantsInvited;
    /**
     * 
     * @type {WebAppData}
     * @memberof Message
     */
    'webAppData'?: WebAppData;
    /**
     * 
     * @type {InlineKeyboardMarkup}
     * @memberof Message
     */
    'replyMarkup'?: InlineKeyboardMarkup;
}
/**
 * 
 * @export
 * @interface MessageAutoDeleteTimerChanged
 */
export interface MessageAutoDeleteTimerChanged {
    /**
     * 
     * @type {number}
     * @memberof MessageAutoDeleteTimerChanged
     */
    'messageAutoDeleteTime'?: number;
}
/**
 * 
 * @export
 * @interface MessageEntity
 */
export interface MessageEntity {
    /**
     * 
     * @type {MessageEntityType}
     * @memberof MessageEntity
     */
    'type'?: MessageEntityType;
    /**
     * 
     * @type {number}
     * @memberof MessageEntity
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof MessageEntity
     */
    'length'?: number;
    /**
     * 
     * @type {string}
     * @memberof MessageEntity
     */
    'url'?: string | null;
    /**
     * 
     * @type {User}
     * @memberof MessageEntity
     */
    'user'?: User;
    /**
     * 
     * @type {string}
     * @memberof MessageEntity
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MessageEntity
     */
    'customEmojiId'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const MessageEntityType = {
    Mention: 'mention',
    Hashtag: 'hashtag',
    BotCommand: 'bot_command',
    Url: 'url',
    Email: 'email',
    Bold: 'bold',
    Italic: 'italic',
    Code: 'code',
    Pre: 'pre',
    TextLink: 'text_link',
    TextMention: 'text_mention',
    PhoneNumber: 'phone_number',
    Cashtag: 'cashtag',
    Underline: 'underline',
    Strikethrough: 'strikethrough',
    Spoiler: 'spoiler',
    CustomEmoji: 'custom_emoji',
    Blockquote: 'blockquote',
    ExpandableBlockquote: 'expandable_blockquote'
} as const;

export type MessageEntityType = typeof MessageEntityType[keyof typeof MessageEntityType];


/**
 * 
 * @export
 * @interface MessageOrigin
 */
export interface MessageOrigin {
    /**
     * 
     * @type {MessageOriginType}
     * @memberof MessageOrigin
     */
    'type'?: MessageOriginType;
    /**
     * 
     * @type {string}
     * @memberof MessageOrigin
     */
    'date'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const MessageOriginType = {
    User: 'user',
    HiddenUser: 'hidden_user',
    Chat: 'chat',
    Channel: 'channel'
} as const;

export type MessageOriginType = typeof MessageOriginType[keyof typeof MessageOriginType];


/**
 * 
 * @export
 * @interface MessageReactionCountUpdated
 */
export interface MessageReactionCountUpdated {
    /**
     * 
     * @type {Chat}
     * @memberof MessageReactionCountUpdated
     */
    'chat'?: Chat;
    /**
     * 
     * @type {number}
     * @memberof MessageReactionCountUpdated
     */
    'messageId'?: number;
    /**
     * 
     * @type {string}
     * @memberof MessageReactionCountUpdated
     */
    'date'?: string;
    /**
     * 
     * @type {Array<ReactionCount>}
     * @memberof MessageReactionCountUpdated
     */
    'reactions'?: Array<ReactionCount> | null;
}
/**
 * 
 * @export
 * @interface MessageReactionUpdated
 */
export interface MessageReactionUpdated {
    /**
     * 
     * @type {Chat}
     * @memberof MessageReactionUpdated
     */
    'chat'?: Chat;
    /**
     * 
     * @type {number}
     * @memberof MessageReactionUpdated
     */
    'messageId'?: number;
    /**
     * 
     * @type {User}
     * @memberof MessageReactionUpdated
     */
    'user'?: User;
    /**
     * 
     * @type {Chat}
     * @memberof MessageReactionUpdated
     */
    'actorChat'?: Chat;
    /**
     * 
     * @type {string}
     * @memberof MessageReactionUpdated
     */
    'date'?: string;
    /**
     * 
     * @type {Array<ReactionType>}
     * @memberof MessageReactionUpdated
     */
    'oldReaction'?: Array<ReactionType> | null;
    /**
     * 
     * @type {Array<ReactionType>}
     * @memberof MessageReactionUpdated
     */
    'newReaction'?: Array<ReactionType> | null;
}
/**
 * Модель средних затрат
 * @export
 * @interface MonthlyAverageDto
 */
export interface MonthlyAverageDto {
    /**
     * Средние затраты
     * @type {number}
     * @memberof MonthlyAverageDto
     */
    'average_month_spent'?: number;
}
/**
 * 
 * @export
 * @interface OrderInfo
 */
export interface OrderInfo {
    /**
     * 
     * @type {string}
     * @memberof OrderInfo
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrderInfo
     */
    'phoneNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrderInfo
     */
    'email'?: string | null;
    /**
     * 
     * @type {ShippingAddress}
     * @memberof OrderInfo
     */
    'shippingAddress'?: ShippingAddress;
}
/**
 * 
 * @export
 * @interface PaidMedia
 */
export interface PaidMedia {
    /**
     * 
     * @type {PaidMediaType}
     * @memberof PaidMedia
     */
    'type'?: PaidMediaType;
}


/**
 * 
 * @export
 * @interface PaidMediaInfo
 */
export interface PaidMediaInfo {
    /**
     * 
     * @type {number}
     * @memberof PaidMediaInfo
     */
    'starCount'?: number;
    /**
     * 
     * @type {Array<PaidMedia>}
     * @memberof PaidMediaInfo
     */
    'paidMedia'?: Array<PaidMedia> | null;
}
/**
 * 
 * @export
 * @interface PaidMediaPurchased
 */
export interface PaidMediaPurchased {
    /**
     * 
     * @type {User}
     * @memberof PaidMediaPurchased
     */
    'from'?: User;
    /**
     * 
     * @type {string}
     * @memberof PaidMediaPurchased
     */
    'paidMediaPayload'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PaidMediaType = {
    Preview: 'preview',
    Photo: 'photo',
    Video: 'video'
} as const;

export type PaidMediaType = typeof PaidMediaType[keyof typeof PaidMediaType];


/**
 * 
 * @export
 * @interface PassportData
 */
export interface PassportData {
    /**
     * 
     * @type {Array<EncryptedPassportElement>}
     * @memberof PassportData
     */
    'data'?: Array<EncryptedPassportElement> | null;
    /**
     * 
     * @type {EncryptedCredentials}
     * @memberof PassportData
     */
    'credentials'?: EncryptedCredentials;
}
/**
 * 
 * @export
 * @interface PassportFile
 */
export interface PassportFile {
    /**
     * 
     * @type {string}
     * @memberof PassportFile
     */
    'fileId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PassportFile
     */
    'fileUniqueId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PassportFile
     */
    'fileSize'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PassportFile
     */
    'fileDate'?: string;
}
/**
 * 
 * @export
 * @interface PhotoSize
 */
export interface PhotoSize {
    /**
     * 
     * @type {string}
     * @memberof PhotoSize
     */
    'fileId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PhotoSize
     */
    'fileUniqueId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PhotoSize
     */
    'fileSize'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PhotoSize
     */
    'width'?: number;
    /**
     * 
     * @type {number}
     * @memberof PhotoSize
     */
    'height'?: number;
}
/**
 * Модель запланированной платы
 * @export
 * @interface PlannedPaymentDto
 */
export interface PlannedPaymentDto {
    /**
     * Уникальный идентификатор
     * @type {string}
     * @memberof PlannedPaymentDto
     */
    'id'?: string;
    /**
     * Объем оплаты
     * @type {number}
     * @memberof PlannedPaymentDto
     */
    'amount'?: number;
    /**
     * Дата
     * @type {string}
     * @memberof PlannedPaymentDto
     */
    'due_date'?: string;
    /**
     * Идентификатор категории
     * @type {string}
     * @memberof PlannedPaymentDto
     */
    'category_id'?: string | null;
}
/**
 * Пагинированный список
 * @export
 * @interface PlannedPaymentDtoPagedList
 */
export interface PlannedPaymentDtoPagedList {
    /**
     * Элементы
     * @type {Array<PlannedPaymentDto>}
     * @memberof PlannedPaymentDtoPagedList
     */
    'items'?: Array<PlannedPaymentDto> | null;
    /**
     * Всего элементов
     * @type {number}
     * @memberof PlannedPaymentDtoPagedList
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface Poll
 */
export interface Poll {
    /**
     * 
     * @type {string}
     * @memberof Poll
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Poll
     */
    'question'?: string | null;
    /**
     * 
     * @type {Array<MessageEntity>}
     * @memberof Poll
     */
    'questionEntities'?: Array<MessageEntity> | null;
    /**
     * 
     * @type {Array<PollOption>}
     * @memberof Poll
     */
    'options'?: Array<PollOption> | null;
    /**
     * 
     * @type {number}
     * @memberof Poll
     */
    'totalVoterCount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Poll
     */
    'isClosed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Poll
     */
    'isAnonymous'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Poll
     */
    'type'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Poll
     */
    'allowsMultipleAnswers'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Poll
     */
    'correctOptionId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Poll
     */
    'explanation'?: string | null;
    /**
     * 
     * @type {Array<MessageEntity>}
     * @memberof Poll
     */
    'explanationEntities'?: Array<MessageEntity> | null;
    /**
     * 
     * @type {number}
     * @memberof Poll
     */
    'openPeriod'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Poll
     */
    'closeDate'?: string | null;
}
/**
 * 
 * @export
 * @interface PollAnswer
 */
export interface PollAnswer {
    /**
     * 
     * @type {string}
     * @memberof PollAnswer
     */
    'pollId'?: string | null;
    /**
     * 
     * @type {Chat}
     * @memberof PollAnswer
     */
    'voterChat'?: Chat;
    /**
     * 
     * @type {User}
     * @memberof PollAnswer
     */
    'user'?: User;
    /**
     * 
     * @type {Array<number>}
     * @memberof PollAnswer
     */
    'optionIds'?: Array<number> | null;
}
/**
 * 
 * @export
 * @interface PollOption
 */
export interface PollOption {
    /**
     * 
     * @type {string}
     * @memberof PollOption
     */
    'text'?: string | null;
    /**
     * 
     * @type {Array<MessageEntity>}
     * @memberof PollOption
     */
    'textEntities'?: Array<MessageEntity> | null;
    /**
     * 
     * @type {number}
     * @memberof PollOption
     */
    'voterCount'?: number;
}
/**
 * 
 * @export
 * @interface PreCheckoutQuery
 */
export interface PreCheckoutQuery {
    /**
     * 
     * @type {string}
     * @memberof PreCheckoutQuery
     */
    'id'?: string | null;
    /**
     * 
     * @type {User}
     * @memberof PreCheckoutQuery
     */
    'from'?: User;
    /**
     * 
     * @type {string}
     * @memberof PreCheckoutQuery
     */
    'currency'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PreCheckoutQuery
     */
    'totalAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof PreCheckoutQuery
     */
    'invoicePayload'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PreCheckoutQuery
     */
    'shippingOptionId'?: string | null;
    /**
     * 
     * @type {OrderInfo}
     * @memberof PreCheckoutQuery
     */
    'orderInfo'?: OrderInfo;
}
/**
 * 
 * @export
 * @interface ProximityAlertTriggered
 */
export interface ProximityAlertTriggered {
    /**
     * 
     * @type {User}
     * @memberof ProximityAlertTriggered
     */
    'traveler'?: User;
    /**
     * 
     * @type {User}
     * @memberof ProximityAlertTriggered
     */
    'watcher'?: User;
    /**
     * 
     * @type {number}
     * @memberof ProximityAlertTriggered
     */
    'distance'?: number;
}
/**
 * 
 * @export
 * @interface ReactionCount
 */
export interface ReactionCount {
    /**
     * 
     * @type {ReactionType}
     * @memberof ReactionCount
     */
    'type'?: ReactionType;
    /**
     * 
     * @type {number}
     * @memberof ReactionCount
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface ReactionType
 */
export interface ReactionType {
    /**
     * 
     * @type {ReactionTypeKind}
     * @memberof ReactionType
     */
    'type'?: ReactionTypeKind;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ReactionTypeKind = {
    Emoji: 'emoji',
    CustomEmoji: 'custom_emoji',
    Paid: 'paid'
} as const;

export type ReactionTypeKind = typeof ReactionTypeKind[keyof typeof ReactionTypeKind];


/**
 * 
 * @export
 * @interface RefundedPayment
 */
export interface RefundedPayment {
    /**
     * 
     * @type {string}
     * @memberof RefundedPayment
     */
    'currency'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof RefundedPayment
     */
    'totalAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof RefundedPayment
     */
    'invoicePayload'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RefundedPayment
     */
    'telegramPaymentChargeId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RefundedPayment
     */
    'providerPaymentChargeId'?: string | null;
}
/**
 * 
 * @export
 * @interface SharedUser
 */
export interface SharedUser {
    /**
     * 
     * @type {number}
     * @memberof SharedUser
     */
    'userId'?: number;
    /**
     * 
     * @type {string}
     * @memberof SharedUser
     */
    'firstName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SharedUser
     */
    'lastName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SharedUser
     */
    'username'?: string | null;
    /**
     * 
     * @type {Array<PhotoSize>}
     * @memberof SharedUser
     */
    'photo'?: Array<PhotoSize> | null;
}
/**
 * 
 * @export
 * @interface ShippingAddress
 */
export interface ShippingAddress {
    /**
     * 
     * @type {string}
     * @memberof ShippingAddress
     */
    'countryCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShippingAddress
     */
    'state'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShippingAddress
     */
    'city'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShippingAddress
     */
    'streetLine1'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShippingAddress
     */
    'streetLine2'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShippingAddress
     */
    'postCode'?: string | null;
}
/**
 * 
 * @export
 * @interface ShippingQuery
 */
export interface ShippingQuery {
    /**
     * 
     * @type {string}
     * @memberof ShippingQuery
     */
    'id'?: string | null;
    /**
     * 
     * @type {User}
     * @memberof ShippingQuery
     */
    'from'?: User;
    /**
     * 
     * @type {string}
     * @memberof ShippingQuery
     */
    'invoicePayload'?: string | null;
    /**
     * 
     * @type {ShippingAddress}
     * @memberof ShippingQuery
     */
    'shippingAddress'?: ShippingAddress;
}
/**
 * 
 * @export
 * @interface Sticker
 */
export interface Sticker {
    /**
     * 
     * @type {string}
     * @memberof Sticker
     */
    'fileId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Sticker
     */
    'fileUniqueId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Sticker
     */
    'fileSize'?: number | null;
    /**
     * 
     * @type {StickerType}
     * @memberof Sticker
     */
    'type'?: StickerType;
    /**
     * 
     * @type {number}
     * @memberof Sticker
     */
    'width'?: number;
    /**
     * 
     * @type {number}
     * @memberof Sticker
     */
    'height'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Sticker
     */
    'isAnimated'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sticker
     */
    'isVideo'?: boolean;
    /**
     * 
     * @type {PhotoSize}
     * @memberof Sticker
     */
    'thumbnail'?: PhotoSize;
    /**
     * 
     * @type {string}
     * @memberof Sticker
     */
    'emoji'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Sticker
     */
    'setName'?: string | null;
    /**
     * 
     * @type {TGFile}
     * @memberof Sticker
     */
    'premiumAnimation'?: TGFile;
    /**
     * 
     * @type {MaskPosition}
     * @memberof Sticker
     */
    'maskPosition'?: MaskPosition;
    /**
     * 
     * @type {string}
     * @memberof Sticker
     */
    'customEmojiId'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Sticker
     */
    'needsRepainting'?: boolean;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const StickerType = {
    Regular: 'regular',
    Mask: 'mask',
    CustomEmoji: 'custom_emoji'
} as const;

export type StickerType = typeof StickerType[keyof typeof StickerType];


/**
 * 
 * @export
 * @interface Story
 */
export interface Story {
    /**
     * 
     * @type {Chat}
     * @memberof Story
     */
    'chat'?: Chat;
    /**
     * 
     * @type {number}
     * @memberof Story
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface SuccessfulPayment
 */
export interface SuccessfulPayment {
    /**
     * 
     * @type {string}
     * @memberof SuccessfulPayment
     */
    'currency'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SuccessfulPayment
     */
    'totalAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessfulPayment
     */
    'invoicePayload'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SuccessfulPayment
     */
    'subscriptionExpirationDate'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SuccessfulPayment
     */
    'isRecurring'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SuccessfulPayment
     */
    'isFirstRecurring'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SuccessfulPayment
     */
    'shippingOptionId'?: string | null;
    /**
     * 
     * @type {OrderInfo}
     * @memberof SuccessfulPayment
     */
    'orderInfo'?: OrderInfo;
    /**
     * 
     * @type {string}
     * @memberof SuccessfulPayment
     */
    'telegramPaymentChargeId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SuccessfulPayment
     */
    'providerPaymentChargeId'?: string | null;
}
/**
 * 
 * @export
 * @interface SwitchInlineQueryChosenChat
 */
export interface SwitchInlineQueryChosenChat {
    /**
     * 
     * @type {string}
     * @memberof SwitchInlineQueryChosenChat
     */
    'query'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SwitchInlineQueryChosenChat
     */
    'allowUserChats'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SwitchInlineQueryChosenChat
     */
    'allowBotChats'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SwitchInlineQueryChosenChat
     */
    'allowGroupChats'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SwitchInlineQueryChosenChat
     */
    'allowChannelChats'?: boolean;
}
/**
 * 
 * @export
 * @interface TGFile
 */
export interface TGFile {
    /**
     * 
     * @type {string}
     * @memberof TGFile
     */
    'fileId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TGFile
     */
    'fileUniqueId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TGFile
     */
    'fileSize'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TGFile
     */
    'filePath'?: string | null;
}
/**
 * 
 * @export
 * @interface TextQuote
 */
export interface TextQuote {
    /**
     * 
     * @type {string}
     * @memberof TextQuote
     */
    'text'?: string | null;
    /**
     * 
     * @type {Array<MessageEntity>}
     * @memberof TextQuote
     */
    'entities'?: Array<MessageEntity> | null;
    /**
     * 
     * @type {number}
     * @memberof TextQuote
     */
    'position'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TextQuote
     */
    'isManual'?: boolean;
}
/**
 * Модель самых затратных категорий
 * @export
 * @interface TopCategoryDto
 */
export interface TopCategoryDto {
    /**
     * Название категории
     * @type {string}
     * @memberof TopCategoryDto
     */
    'category'?: string | null;
    /**
     * Всего потрачено
     * @type {number}
     * @memberof TopCategoryDto
     */
    'total_spent'?: number;
}
/**
 * Модель транзакции
 * @export
 * @interface TransactionDto
 */
export interface TransactionDto {
    /**
     * Уникальный идентификатор транзакции.
     * @type {string}
     * @memberof TransactionDto
     */
    'id'?: string;
    /**
     * Уникальный идентификатор пользователя.
     * @type {string}
     * @memberof TransactionDto
     */
    'user_id'?: string;
    /**
     * Сумма транзакции.
     * @type {number}
     * @memberof TransactionDto
     */
    'amount'?: number;
    /**
     * Дата транзакции.
     * @type {string}
     * @memberof TransactionDto
     */
    'date'?: string;
}
/**
 * Пагинированный список
 * @export
 * @interface TransactionDtoPagedList
 */
export interface TransactionDtoPagedList {
    /**
     * Элементы
     * @type {Array<TransactionDto>}
     * @memberof TransactionDtoPagedList
     */
    'items'?: Array<TransactionDto> | null;
    /**
     * Всего элементов
     * @type {number}
     * @memberof TransactionDtoPagedList
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface Update
 */
export interface Update {
    /**
     * 
     * @type {number}
     * @memberof Update
     */
    'update_id'?: number;
    /**
     * 
     * @type {Message}
     * @memberof Update
     */
    'message'?: Message;
    /**
     * 
     * @type {Message}
     * @memberof Update
     */
    'editedMessage'?: Message;
    /**
     * 
     * @type {Message}
     * @memberof Update
     */
    'channelPost'?: Message;
    /**
     * 
     * @type {Message}
     * @memberof Update
     */
    'editedChannelPost'?: Message;
    /**
     * 
     * @type {BusinessConnection}
     * @memberof Update
     */
    'businessConnection'?: BusinessConnection;
    /**
     * 
     * @type {Message}
     * @memberof Update
     */
    'businessMessage'?: Message;
    /**
     * 
     * @type {Message}
     * @memberof Update
     */
    'editedBusinessMessage'?: Message;
    /**
     * 
     * @type {BusinessMessagesDeleted}
     * @memberof Update
     */
    'deletedBusinessMessages'?: BusinessMessagesDeleted;
    /**
     * 
     * @type {MessageReactionUpdated}
     * @memberof Update
     */
    'messageReaction'?: MessageReactionUpdated;
    /**
     * 
     * @type {MessageReactionCountUpdated}
     * @memberof Update
     */
    'messageReactionCount'?: MessageReactionCountUpdated;
    /**
     * 
     * @type {InlineQuery}
     * @memberof Update
     */
    'inlineQuery'?: InlineQuery;
    /**
     * 
     * @type {ChosenInlineResult}
     * @memberof Update
     */
    'chosenInlineResult'?: ChosenInlineResult;
    /**
     * 
     * @type {CallbackQuery}
     * @memberof Update
     */
    'callbackQuery'?: CallbackQuery;
    /**
     * 
     * @type {ShippingQuery}
     * @memberof Update
     */
    'shippingQuery'?: ShippingQuery;
    /**
     * 
     * @type {PreCheckoutQuery}
     * @memberof Update
     */
    'preCheckoutQuery'?: PreCheckoutQuery;
    /**
     * 
     * @type {PaidMediaPurchased}
     * @memberof Update
     */
    'purchasedPaidMedia'?: PaidMediaPurchased;
    /**
     * 
     * @type {Poll}
     * @memberof Update
     */
    'poll'?: Poll;
    /**
     * 
     * @type {PollAnswer}
     * @memberof Update
     */
    'pollAnswer'?: PollAnswer;
    /**
     * 
     * @type {ChatMemberUpdated}
     * @memberof Update
     */
    'myChatMember'?: ChatMemberUpdated;
    /**
     * 
     * @type {ChatMemberUpdated}
     * @memberof Update
     */
    'chatMember'?: ChatMemberUpdated;
    /**
     * 
     * @type {ChatJoinRequest}
     * @memberof Update
     */
    'chatJoinRequest'?: ChatJoinRequest;
    /**
     * 
     * @type {ChatBoostUpdated}
     * @memberof Update
     */
    'chatBoost'?: ChatBoostUpdated;
    /**
     * 
     * @type {ChatBoostRemoved}
     * @memberof Update
     */
    'removedChatBoost'?: ChatBoostRemoved;
}
/**
 * Запрос на обновление запланированного платежа
 * @export
 * @interface UpdateBudgetCommand
 */
export interface UpdateBudgetCommand {
    /**
     * Идентификатор запланированного платежа
     * @type {string}
     * @memberof UpdateBudgetCommand
     */
    'id'?: string;
    /**
     * Величина лимита
     * @type {number}
     * @memberof UpdateBudgetCommand
     */
    'amount'?: number;
    /**
     * Идентификатор категории
     * @type {string}
     * @memberof UpdateBudgetCommand
     */
    'category_id'?: string | null;
}
/**
 * Запрос на обновление категории
 * @export
 * @interface UpdateCategoryCommand
 */
export interface UpdateCategoryCommand {
    /**
     * Уникальный идентификатор категории
     * @type {string}
     * @memberof UpdateCategoryCommand
     */
    'id'?: string;
    /**
     * Название категории
     * @type {string}
     * @memberof UpdateCategoryCommand
     */
    'name'?: string | null;
    /**
     * 
     * @type {CategoryType}
     * @memberof UpdateCategoryCommand
     */
    'type'?: CategoryType;
}


/**
 * Запрос на обновление запланированного платежа
 * @export
 * @interface UpdatePlannedPaymentCommand
 */
export interface UpdatePlannedPaymentCommand {
    /**
     * Идентификатор запланированного платежа
     * @type {string}
     * @memberof UpdatePlannedPaymentCommand
     */
    'id'?: string;
    /**
     * Объем оплаты
     * @type {number}
     * @memberof UpdatePlannedPaymentCommand
     */
    'amount'?: number;
    /**
     * Дата
     * @type {string}
     * @memberof UpdatePlannedPaymentCommand
     */
    'due_date'?: string;
    /**
     * Описание
     * @type {string}
     * @memberof UpdatePlannedPaymentCommand
     */
    'description'?: string | null;
    /**
     * Идентификатор категории
     * @type {string}
     * @memberof UpdatePlannedPaymentCommand
     */
    'category_id'?: string | null;
}
/**
 * Команда для обновления транзакции.
 * @export
 * @interface UpdateTransactionCommand
 */
export interface UpdateTransactionCommand {
    /**
     * Уникальный идентификатор транзакции.
     * @type {string}
     * @memberof UpdateTransactionCommand
     */
    'id'?: string;
    /**
     * Уникальный идентификатор категории.
     * @type {string}
     * @memberof UpdateTransactionCommand
     */
    'category_id'?: string;
    /**
     * Сумма транзакции.
     * @type {number}
     * @memberof UpdateTransactionCommand
     */
    'amount'?: number;
    /**
     * Описание транзакции.
     * @type {string}
     * @memberof UpdateTransactionCommand
     */
    'description'?: string | null;
    /**
     * Дата транзакции.
     * @type {string}
     * @memberof UpdateTransactionCommand
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'isBot'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'firstName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'languageCode'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'isPremium'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'addedToAttachmentMenu'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'canJoinGroups'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'canReadAllGroupMessages'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'supportsInlineQueries'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'canConnectToBusiness'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'hasMainWebApp'?: boolean;
}
/**
 * Модель пользователя
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     * Электронная почта
     * @type {string}
     * @memberof UserDto
     */
    'email'?: string | null;
    /**
     * Дата создания
     * @type {string}
     * @memberof UserDto
     */
    'created_at'?: string;
    /**
     * Привязал Телеграм
     * @type {boolean}
     * @memberof UserDto
     */
    'linked_telegram'?: boolean;
}
/**
 * 
 * @export
 * @interface UsersShared
 */
export interface UsersShared {
    /**
     * 
     * @type {number}
     * @memberof UsersShared
     */
    'requestId'?: number;
    /**
     * 
     * @type {Array<SharedUser>}
     * @memberof UsersShared
     */
    'users'?: Array<SharedUser> | null;
}
/**
 * 
 * @export
 * @interface Venue
 */
export interface Venue {
    /**
     * 
     * @type {Location}
     * @memberof Venue
     */
    'location'?: Location;
    /**
     * 
     * @type {string}
     * @memberof Venue
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Venue
     */
    'address'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Venue
     */
    'foursquareId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Venue
     */
    'foursquareType'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Venue
     */
    'googlePlaceId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Venue
     */
    'googlePlaceType'?: string | null;
}
/**
 * 
 * @export
 * @interface Video
 */
export interface Video {
    /**
     * 
     * @type {string}
     * @memberof Video
     */
    'fileId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Video
     */
    'fileUniqueId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Video
     */
    'fileSize'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Video
     */
    'width'?: number;
    /**
     * 
     * @type {number}
     * @memberof Video
     */
    'height'?: number;
    /**
     * 
     * @type {number}
     * @memberof Video
     */
    'duration'?: number;
    /**
     * 
     * @type {PhotoSize}
     * @memberof Video
     */
    'thumbnail'?: PhotoSize;
    /**
     * 
     * @type {Array<PhotoSize>}
     * @memberof Video
     */
    'cover'?: Array<PhotoSize> | null;
    /**
     * 
     * @type {number}
     * @memberof Video
     */
    'startTimestamp'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Video
     */
    'fileName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Video
     */
    'mimeType'?: string | null;
}
/**
 * 
 * @export
 * @interface VideoChatEnded
 */
export interface VideoChatEnded {
    /**
     * 
     * @type {number}
     * @memberof VideoChatEnded
     */
    'duration'?: number;
}
/**
 * 
 * @export
 * @interface VideoChatParticipantsInvited
 */
export interface VideoChatParticipantsInvited {
    /**
     * 
     * @type {Array<User>}
     * @memberof VideoChatParticipantsInvited
     */
    'users'?: Array<User> | null;
}
/**
 * 
 * @export
 * @interface VideoChatScheduled
 */
export interface VideoChatScheduled {
    /**
     * 
     * @type {string}
     * @memberof VideoChatScheduled
     */
    'startDate'?: string;
}
/**
 * 
 * @export
 * @interface VideoNote
 */
export interface VideoNote {
    /**
     * 
     * @type {string}
     * @memberof VideoNote
     */
    'fileId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VideoNote
     */
    'fileUniqueId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof VideoNote
     */
    'fileSize'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof VideoNote
     */
    'length'?: number;
    /**
     * 
     * @type {number}
     * @memberof VideoNote
     */
    'duration'?: number;
    /**
     * 
     * @type {PhotoSize}
     * @memberof VideoNote
     */
    'thumbnail'?: PhotoSize;
}
/**
 * 
 * @export
 * @interface Voice
 */
export interface Voice {
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'fileId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'fileUniqueId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Voice
     */
    'fileSize'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Voice
     */
    'duration'?: number;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'mimeType'?: string | null;
}
/**
 * 
 * @export
 * @interface WebAppData
 */
export interface WebAppData {
    /**
     * 
     * @type {string}
     * @memberof WebAppData
     */
    'data'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebAppData
     */
    'buttonText'?: string | null;
}
/**
 * 
 * @export
 * @interface WebAppInfo
 */
export interface WebAppInfo {
    /**
     * 
     * @type {string}
     * @memberof WebAppInfo
     */
    'url'?: string | null;
}
/**
 * 
 * @export
 * @interface WriteAccessAllowed
 */
export interface WriteAccessAllowed {
    /**
     * 
     * @type {boolean}
     * @memberof WriteAccessAllowed
     */
    'fromRequest'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WriteAccessAllowed
     */
    'webAppName'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof WriteAccessAllowed
     */
    'fromAttachmentMenu'?: boolean;
}

/**
 * AnalyticsApi - axios parameter creator
 * @export
 */
export const AnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Получение общего баланса пользователя
         * @param {object} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAnalyticsBalanceGet: async (query?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/analytics/balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                for (const [key, value] of Object.entries(query)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Получение расходов по категориям
         * @param {object} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAnalyticsCategorySpendingGet: async (query?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/analytics/category-spending`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                for (const [key, value] of Object.entries(query)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Получение среднего уровня месячных расходов
         * @param {object} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAnalyticsMonthlyAverageGet: async (query?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/analytics/monthly-average`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                for (const [key, value] of Object.entries(query)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Получение динамики расходов за месяц
         * @param {object} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAnalyticsMonthlyTrendGet: async (query?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/analytics/monthly-trend`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                for (const [key, value] of Object.entries(query)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Получение топ-3 самых затратных категорий
         * @param {object} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAnalyticsTopCategoriesGet: async (query?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/analytics/top-categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                for (const [key, value] of Object.entries(query)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalyticsApi - functional programming interface
 * @export
 */
export const AnalyticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalyticsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Получение общего баланса пользователя
         * @param {object} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAnalyticsBalanceGet(query?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAnalyticsBalanceGet(query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.apiAnalyticsBalanceGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Получение расходов по категориям
         * @param {object} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAnalyticsCategorySpendingGet(query?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CategorySpendingDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAnalyticsCategorySpendingGet(query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.apiAnalyticsCategorySpendingGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Получение среднего уровня месячных расходов
         * @param {object} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAnalyticsMonthlyAverageGet(query?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MonthlyAverageDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAnalyticsMonthlyAverageGet(query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.apiAnalyticsMonthlyAverageGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Получение динамики расходов за месяц
         * @param {object} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAnalyticsMonthlyTrendGet(query?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DailySpendingDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAnalyticsMonthlyTrendGet(query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.apiAnalyticsMonthlyTrendGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Получение топ-3 самых затратных категорий
         * @param {object} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAnalyticsTopCategoriesGet(query?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TopCategoryDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAnalyticsTopCategoriesGet(query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.apiAnalyticsTopCategoriesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnalyticsApi - factory interface
 * @export
 */
export const AnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalyticsApiFp(configuration)
    return {
        /**
         * 
         * @summary Получение общего баланса пользователя
         * @param {object} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAnalyticsBalanceGet(query?: object, options?: RawAxiosRequestConfig): AxiosPromise<BalanceDto> {
            return localVarFp.apiAnalyticsBalanceGet(query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Получение расходов по категориям
         * @param {object} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAnalyticsCategorySpendingGet(query?: object, options?: RawAxiosRequestConfig): AxiosPromise<Array<CategorySpendingDto>> {
            return localVarFp.apiAnalyticsCategorySpendingGet(query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Получение среднего уровня месячных расходов
         * @param {object} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAnalyticsMonthlyAverageGet(query?: object, options?: RawAxiosRequestConfig): AxiosPromise<MonthlyAverageDto> {
            return localVarFp.apiAnalyticsMonthlyAverageGet(query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Получение динамики расходов за месяц
         * @param {object} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAnalyticsMonthlyTrendGet(query?: object, options?: RawAxiosRequestConfig): AxiosPromise<Array<DailySpendingDto>> {
            return localVarFp.apiAnalyticsMonthlyTrendGet(query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Получение топ-3 самых затратных категорий
         * @param {object} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAnalyticsTopCategoriesGet(query?: object, options?: RawAxiosRequestConfig): AxiosPromise<Array<TopCategoryDto>> {
            return localVarFp.apiAnalyticsTopCategoriesGet(query, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
export class AnalyticsApi extends BaseAPI {
    /**
     * 
     * @summary Получение общего баланса пользователя
     * @param {object} [query] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public apiAnalyticsBalanceGet(query?: object, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).apiAnalyticsBalanceGet(query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Получение расходов по категориям
     * @param {object} [query] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public apiAnalyticsCategorySpendingGet(query?: object, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).apiAnalyticsCategorySpendingGet(query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Получение среднего уровня месячных расходов
     * @param {object} [query] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public apiAnalyticsMonthlyAverageGet(query?: object, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).apiAnalyticsMonthlyAverageGet(query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Получение динамики расходов за месяц
     * @param {object} [query] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public apiAnalyticsMonthlyTrendGet(query?: object, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).apiAnalyticsMonthlyTrendGet(query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Получение топ-3 самых затратных категорий
     * @param {object} [query] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public apiAnalyticsTopCategoriesGet(query?: object, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).apiAnalyticsTopCategoriesGet(query, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BudgetApi - axios parameter creator
 * @export
 */
export const BudgetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Получение всех лимитов
         * @param {string} [categoryId] Идентификатор категории
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Предел
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBudgetsGet: async (categoryId?: string, page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/budgets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (categoryId !== undefined) {
                localVarQueryParameter['category_id'] = categoryId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Удаление лимита
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBudgetsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiBudgetsIdDelete', 'id', id)
            const localVarPath = `/api/budgets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Получение лимита по ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBudgetsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiBudgetsIdGet', 'id', id)
            const localVarPath = `/api/budgets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Обновление лимита
         * @param {string} id 
         * @param {UpdateBudgetCommand} [updateBudgetCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBudgetsIdPut: async (id: string, updateBudgetCommand?: UpdateBudgetCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiBudgetsIdPut', 'id', id)
            const localVarPath = `/api/budgets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateBudgetCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Создание лимита
         * @param {CreateBudgetCommand} [createBudgetCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBudgetsPost: async (createBudgetCommand?: CreateBudgetCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/budgets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBudgetCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BudgetApi - functional programming interface
 * @export
 */
export const BudgetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BudgetApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Получение всех лимитов
         * @param {string} [categoryId] Идентификатор категории
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Предел
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBudgetsGet(categoryId?: string, page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetDtoPagedList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBudgetsGet(categoryId, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BudgetApi.apiBudgetsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Удаление лимита
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBudgetsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBudgetsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BudgetApi.apiBudgetsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Получение лимита по ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBudgetsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedBudgetDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBudgetsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BudgetApi.apiBudgetsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Обновление лимита
         * @param {string} id 
         * @param {UpdateBudgetCommand} [updateBudgetCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBudgetsIdPut(id: string, updateBudgetCommand?: UpdateBudgetCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBudgetsIdPut(id, updateBudgetCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BudgetApi.apiBudgetsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Создание лимита
         * @param {CreateBudgetCommand} [createBudgetCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBudgetsPost(createBudgetCommand?: CreateBudgetCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBudgetsPost(createBudgetCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BudgetApi.apiBudgetsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BudgetApi - factory interface
 * @export
 */
export const BudgetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BudgetApiFp(configuration)
    return {
        /**
         * 
         * @summary Получение всех лимитов
         * @param {string} [categoryId] Идентификатор категории
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Предел
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBudgetsGet(categoryId?: string, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<BudgetDtoPagedList> {
            return localVarFp.apiBudgetsGet(categoryId, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Удаление лимита
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBudgetsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiBudgetsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Получение лимита по ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBudgetsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DetailedBudgetDto> {
            return localVarFp.apiBudgetsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Обновление лимита
         * @param {string} id 
         * @param {UpdateBudgetCommand} [updateBudgetCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBudgetsIdPut(id: string, updateBudgetCommand?: UpdateBudgetCommand, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiBudgetsIdPut(id, updateBudgetCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Создание лимита
         * @param {CreateBudgetCommand} [createBudgetCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBudgetsPost(createBudgetCommand?: CreateBudgetCommand, options?: RawAxiosRequestConfig): AxiosPromise<BudgetDto> {
            return localVarFp.apiBudgetsPost(createBudgetCommand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BudgetApi - object-oriented interface
 * @export
 * @class BudgetApi
 * @extends {BaseAPI}
 */
export class BudgetApi extends BaseAPI {
    /**
     * 
     * @summary Получение всех лимитов
     * @param {string} [categoryId] Идентификатор категории
     * @param {number} [page] Номер страницы
     * @param {number} [limit] Предел
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetApi
     */
    public apiBudgetsGet(categoryId?: string, page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return BudgetApiFp(this.configuration).apiBudgetsGet(categoryId, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Удаление лимита
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetApi
     */
    public apiBudgetsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return BudgetApiFp(this.configuration).apiBudgetsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Получение лимита по ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetApi
     */
    public apiBudgetsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return BudgetApiFp(this.configuration).apiBudgetsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Обновление лимита
     * @param {string} id 
     * @param {UpdateBudgetCommand} [updateBudgetCommand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetApi
     */
    public apiBudgetsIdPut(id: string, updateBudgetCommand?: UpdateBudgetCommand, options?: RawAxiosRequestConfig) {
        return BudgetApiFp(this.configuration).apiBudgetsIdPut(id, updateBudgetCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Создание лимита
     * @param {CreateBudgetCommand} [createBudgetCommand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetApi
     */
    public apiBudgetsPost(createBudgetCommand?: CreateBudgetCommand, options?: RawAxiosRequestConfig) {
        return BudgetApiFp(this.configuration).apiBudgetsPost(createBudgetCommand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CategoriesApi - axios parameter creator
 * @export
 */
export const CategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Получение всех категорий
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Предел
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCategoriesGet: async (page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Удаление категории
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCategoriesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCategoriesIdDelete', 'id', id)
            const localVarPath = `/api/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Получение категории по ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCategoriesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCategoriesIdGet', 'id', id)
            const localVarPath = `/api/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Обновление категории
         * @param {string} id 
         * @param {UpdateCategoryCommand} [updateCategoryCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCategoriesIdPut: async (id: string, updateCategoryCommand?: UpdateCategoryCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCategoriesIdPut', 'id', id)
            const localVarPath = `/api/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCategoryCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Создание категории
         * @param {CreateCategoryCommand} [createCategoryCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCategoriesPost: async (createCategoryCommand?: CreateCategoryCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCategoryCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoriesApi - functional programming interface
 * @export
 */
export const CategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Получение всех категорий
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Предел
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCategoriesGet(page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryDtoPagedList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCategoriesGet(page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.apiCategoriesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Удаление категории
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCategoriesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCategoriesIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.apiCategoriesIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Получение категории по ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCategoriesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedCategoryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCategoriesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.apiCategoriesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Обновление категории
         * @param {string} id 
         * @param {UpdateCategoryCommand} [updateCategoryCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCategoriesIdPut(id: string, updateCategoryCommand?: UpdateCategoryCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCategoriesIdPut(id, updateCategoryCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.apiCategoriesIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Создание категории
         * @param {CreateCategoryCommand} [createCategoryCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCategoriesPost(createCategoryCommand?: CreateCategoryCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCategoriesPost(createCategoryCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.apiCategoriesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CategoriesApi - factory interface
 * @export
 */
export const CategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Получение всех категорий
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Предел
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCategoriesGet(page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<CategoryDtoPagedList> {
            return localVarFp.apiCategoriesGet(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Удаление категории
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCategoriesIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiCategoriesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Получение категории по ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCategoriesIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DetailedCategoryDto> {
            return localVarFp.apiCategoriesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Обновление категории
         * @param {string} id 
         * @param {UpdateCategoryCommand} [updateCategoryCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCategoriesIdPut(id: string, updateCategoryCommand?: UpdateCategoryCommand, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiCategoriesIdPut(id, updateCategoryCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Создание категории
         * @param {CreateCategoryCommand} [createCategoryCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCategoriesPost(createCategoryCommand?: CreateCategoryCommand, options?: RawAxiosRequestConfig): AxiosPromise<CategoryDto> {
            return localVarFp.apiCategoriesPost(createCategoryCommand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
export class CategoriesApi extends BaseAPI {
    /**
     * 
     * @summary Получение всех категорий
     * @param {number} [page] Номер страницы
     * @param {number} [limit] Предел
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public apiCategoriesGet(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).apiCategoriesGet(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Удаление категории
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public apiCategoriesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).apiCategoriesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Получение категории по ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public apiCategoriesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).apiCategoriesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Обновление категории
     * @param {string} id 
     * @param {UpdateCategoryCommand} [updateCategoryCommand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public apiCategoriesIdPut(id: string, updateCategoryCommand?: UpdateCategoryCommand, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).apiCategoriesIdPut(id, updateCategoryCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Создание категории
     * @param {CreateCategoryCommand} [createCategoryCommand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public apiCategoriesPost(createCategoryCommand?: CreateCategoryCommand, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).apiCategoriesPost(createCategoryCommand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PlannedPaymentApi - axios parameter creator
 * @export
 */
export const PlannedPaymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Получение всех платежей
         * @param {string} [categoryId] Идентификатор категории
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Предел
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsGet: async (categoryId?: string, page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (categoryId !== undefined) {
                localVarQueryParameter['category_id'] = categoryId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Удаление платежа
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPaymentsIdDelete', 'id', id)
            const localVarPath = `/api/payments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Получение платежа по ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPaymentsIdGet', 'id', id)
            const localVarPath = `/api/payments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Обновление платежа
         * @param {string} id 
         * @param {UpdatePlannedPaymentCommand} [updatePlannedPaymentCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsIdPut: async (id: string, updatePlannedPaymentCommand?: UpdatePlannedPaymentCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPaymentsIdPut', 'id', id)
            const localVarPath = `/api/payments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePlannedPaymentCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Создание платежа
         * @param {CreatePlannedPaymentCommand} [createPlannedPaymentCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsPost: async (createPlannedPaymentCommand?: CreatePlannedPaymentCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPlannedPaymentCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlannedPaymentApi - functional programming interface
 * @export
 */
export const PlannedPaymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlannedPaymentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Получение всех платежей
         * @param {string} [categoryId] Идентификатор категории
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Предел
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPaymentsGet(categoryId?: string, page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlannedPaymentDtoPagedList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPaymentsGet(categoryId, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlannedPaymentApi.apiPaymentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Удаление платежа
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPaymentsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPaymentsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlannedPaymentApi.apiPaymentsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Получение платежа по ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPaymentsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedPlannedPaymentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPaymentsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlannedPaymentApi.apiPaymentsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Обновление платежа
         * @param {string} id 
         * @param {UpdatePlannedPaymentCommand} [updatePlannedPaymentCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPaymentsIdPut(id: string, updatePlannedPaymentCommand?: UpdatePlannedPaymentCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPaymentsIdPut(id, updatePlannedPaymentCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlannedPaymentApi.apiPaymentsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Создание платежа
         * @param {CreatePlannedPaymentCommand} [createPlannedPaymentCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPaymentsPost(createPlannedPaymentCommand?: CreatePlannedPaymentCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlannedPaymentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPaymentsPost(createPlannedPaymentCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlannedPaymentApi.apiPaymentsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PlannedPaymentApi - factory interface
 * @export
 */
export const PlannedPaymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlannedPaymentApiFp(configuration)
    return {
        /**
         * 
         * @summary Получение всех платежей
         * @param {string} [categoryId] Идентификатор категории
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Предел
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsGet(categoryId?: string, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<PlannedPaymentDtoPagedList> {
            return localVarFp.apiPaymentsGet(categoryId, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Удаление платежа
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiPaymentsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Получение платежа по ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DetailedPlannedPaymentDto> {
            return localVarFp.apiPaymentsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Обновление платежа
         * @param {string} id 
         * @param {UpdatePlannedPaymentCommand} [updatePlannedPaymentCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsIdPut(id: string, updatePlannedPaymentCommand?: UpdatePlannedPaymentCommand, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiPaymentsIdPut(id, updatePlannedPaymentCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Создание платежа
         * @param {CreatePlannedPaymentCommand} [createPlannedPaymentCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsPost(createPlannedPaymentCommand?: CreatePlannedPaymentCommand, options?: RawAxiosRequestConfig): AxiosPromise<PlannedPaymentDto> {
            return localVarFp.apiPaymentsPost(createPlannedPaymentCommand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlannedPaymentApi - object-oriented interface
 * @export
 * @class PlannedPaymentApi
 * @extends {BaseAPI}
 */
export class PlannedPaymentApi extends BaseAPI {
    /**
     * 
     * @summary Получение всех платежей
     * @param {string} [categoryId] Идентификатор категории
     * @param {number} [page] Номер страницы
     * @param {number} [limit] Предел
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlannedPaymentApi
     */
    public apiPaymentsGet(categoryId?: string, page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return PlannedPaymentApiFp(this.configuration).apiPaymentsGet(categoryId, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Удаление платежа
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlannedPaymentApi
     */
    public apiPaymentsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return PlannedPaymentApiFp(this.configuration).apiPaymentsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Получение платежа по ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlannedPaymentApi
     */
    public apiPaymentsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return PlannedPaymentApiFp(this.configuration).apiPaymentsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Обновление платежа
     * @param {string} id 
     * @param {UpdatePlannedPaymentCommand} [updatePlannedPaymentCommand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlannedPaymentApi
     */
    public apiPaymentsIdPut(id: string, updatePlannedPaymentCommand?: UpdatePlannedPaymentCommand, options?: RawAxiosRequestConfig) {
        return PlannedPaymentApiFp(this.configuration).apiPaymentsIdPut(id, updatePlannedPaymentCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Создание платежа
     * @param {CreatePlannedPaymentCommand} [createPlannedPaymentCommand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlannedPaymentApi
     */
    public apiPaymentsPost(createPlannedPaymentCommand?: CreatePlannedPaymentCommand, options?: RawAxiosRequestConfig) {
        return PlannedPaymentApiFp(this.configuration).apiPaymentsPost(createPlannedPaymentCommand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TelegramApi - axios parameter creator
 * @export
 */
export const TelegramApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Обработчик вебхука
         * @param {Update} [update] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBotPost: async (update?: Update, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/bot`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(update, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TelegramApi - functional programming interface
 * @export
 */
export const TelegramApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TelegramApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Обработчик вебхука
         * @param {Update} [update] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBotPost(update?: Update, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBotPost(update, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TelegramApi.apiBotPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TelegramApi - factory interface
 * @export
 */
export const TelegramApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TelegramApiFp(configuration)
    return {
        /**
         * 
         * @summary Обработчик вебхука
         * @param {Update} [update] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBotPost(update?: Update, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiBotPost(update, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TelegramApi - object-oriented interface
 * @export
 * @class TelegramApi
 * @extends {BaseAPI}
 */
export class TelegramApi extends BaseAPI {
    /**
     * 
     * @summary Обработчик вебхука
     * @param {Update} [update] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegramApi
     */
    public apiBotPost(update?: Update, options?: RawAxiosRequestConfig) {
        return TelegramApiFp(this.configuration).apiBotPost(update, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransactionApi - axios parameter creator
 * @export
 */
export const TransactionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Получение всех транзакций
         * @param {string} [categoryId] Идентификатор категории
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Предел
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsGet: async (categoryId?: string, page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (categoryId !== undefined) {
                localVarQueryParameter['category_id'] = categoryId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Удаление транзакции
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiTransactionsIdDelete', 'id', id)
            const localVarPath = `/api/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Получение транзакции по ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiTransactionsIdGet', 'id', id)
            const localVarPath = `/api/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Обновление транзакции
         * @param {string} id 
         * @param {UpdateTransactionCommand} [updateTransactionCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsIdPut: async (id: string, updateTransactionCommand?: UpdateTransactionCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiTransactionsIdPut', 'id', id)
            const localVarPath = `/api/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTransactionCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Создание транзакции
         * @param {CreateTransactionCommand} [createTransactionCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsPost: async (createTransactionCommand?: CreateTransactionCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTransactionCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionApi - functional programming interface
 * @export
 */
export const TransactionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Получение всех транзакций
         * @param {string} [categoryId] Идентификатор категории
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Предел
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsGet(categoryId?: string, page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDtoPagedList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsGet(categoryId, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.apiTransactionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Удаление транзакции
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.apiTransactionsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Получение транзакции по ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedTransactionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.apiTransactionsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Обновление транзакции
         * @param {string} id 
         * @param {UpdateTransactionCommand} [updateTransactionCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsIdPut(id: string, updateTransactionCommand?: UpdateTransactionCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsIdPut(id, updateTransactionCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.apiTransactionsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Создание транзакции
         * @param {CreateTransactionCommand} [createTransactionCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsPost(createTransactionCommand?: CreateTransactionCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsPost(createTransactionCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.apiTransactionsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TransactionApi - factory interface
 * @export
 */
export const TransactionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionApiFp(configuration)
    return {
        /**
         * 
         * @summary Получение всех транзакций
         * @param {string} [categoryId] Идентификатор категории
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Предел
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsGet(categoryId?: string, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<TransactionDtoPagedList> {
            return localVarFp.apiTransactionsGet(categoryId, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Удаление транзакции
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiTransactionsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Получение транзакции по ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DetailedTransactionDto> {
            return localVarFp.apiTransactionsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Обновление транзакции
         * @param {string} id 
         * @param {UpdateTransactionCommand} [updateTransactionCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsIdPut(id: string, updateTransactionCommand?: UpdateTransactionCommand, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiTransactionsIdPut(id, updateTransactionCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Создание транзакции
         * @param {CreateTransactionCommand} [createTransactionCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsPost(createTransactionCommand?: CreateTransactionCommand, options?: RawAxiosRequestConfig): AxiosPromise<TransactionDto> {
            return localVarFp.apiTransactionsPost(createTransactionCommand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionApi - object-oriented interface
 * @export
 * @class TransactionApi
 * @extends {BaseAPI}
 */
export class TransactionApi extends BaseAPI {
    /**
     * 
     * @summary Получение всех транзакций
     * @param {string} [categoryId] Идентификатор категории
     * @param {number} [page] Номер страницы
     * @param {number} [limit] Предел
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public apiTransactionsGet(categoryId?: string, page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).apiTransactionsGet(categoryId, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Удаление транзакции
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public apiTransactionsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).apiTransactionsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Получение транзакции по ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public apiTransactionsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).apiTransactionsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Обновление транзакции
     * @param {string} id 
     * @param {UpdateTransactionCommand} [updateTransactionCommand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public apiTransactionsIdPut(id: string, updateTransactionCommand?: UpdateTransactionCommand, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).apiTransactionsIdPut(id, updateTransactionCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Создание транзакции
     * @param {CreateTransactionCommand} [createTransactionCommand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public apiTransactionsPost(createTransactionCommand?: CreateTransactionCommand, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).apiTransactionsPost(createTransactionCommand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Привязать пользователя Телеграм
         * @param {LinkUserToTelegramCommand} [linkUserToTelegramCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersLinkPost: async (linkUserToTelegramCommand?: LinkUserToTelegramCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(linkUserToTelegramCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Получить профиль текущего пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersProfileGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Привязать пользователя Телеграм
         * @param {LinkUserToTelegramCommand} [linkUserToTelegramCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersLinkPost(linkUserToTelegramCommand?: LinkUserToTelegramCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersLinkPost(linkUserToTelegramCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersLinkPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Получить профиль текущего пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersProfileGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersProfileGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersProfileGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Привязать пользователя Телеграм
         * @param {LinkUserToTelegramCommand} [linkUserToTelegramCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersLinkPost(linkUserToTelegramCommand?: LinkUserToTelegramCommand, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiUsersLinkPost(linkUserToTelegramCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Получить профиль текущего пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersProfileGet(options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.apiUsersProfileGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Привязать пользователя Телеграм
     * @param {LinkUserToTelegramCommand} [linkUserToTelegramCommand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersLinkPost(linkUserToTelegramCommand?: LinkUserToTelegramCommand, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersLinkPost(linkUserToTelegramCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Получить профиль текущего пользователя
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersProfileGet(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersProfileGet(options).then((request) => request(this.axios, this.basePath));
    }
}



